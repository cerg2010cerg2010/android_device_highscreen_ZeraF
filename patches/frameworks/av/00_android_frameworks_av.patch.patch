diff --git a/camera/Android.mk b/camera/Android.mk
index 36f6da107..2448832f3 100644
--- a/camera/Android.mk
+++ b/camera/Android.mk
@@ -58,6 +58,13 @@ else
 LOCAL_WHOLE_STATIC_LIBRARIES += libcamera_parameters
 endif
 
+# Mediatek
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+LOCAL_SRC_FILES += \
+	mediatek/MtkCamera.cpp \
+	mediatek/MtkCameraParameters.cpp
+endif
+
 LOCAL_MODULE:= libcamera_client
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/camera/mediatek/MtkCamera.cpp b/camera/mediatek/MtkCamera.cpp
new file mode 100644
index 000000000..5f56c9473
--- /dev/null
+++ b/camera/mediatek/MtkCamera.cpp
@@ -0,0 +1,212 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ * 
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ * 
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+**
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "MtkCamera"
+#include <utils/Log.h>
+
+#include <binder/MemoryBase.h>
+#include <binder/MemoryHeapBase.h>
+#include <camera/MtkCamera.h>
+
+namespace android {
+
+
+MtkCamMsgExtDataHelper::
+MtkCamMsgExtDataHelper()
+    : mIsValid(false)
+    , mspData(0)
+    , mspHeap(0)
+    , mDataOffset(0)
+    , mDataSize(0)
+{
+    ::memset(&mExtDataHdr, 0, sizeof(mExtDataHdr));
+}
+
+
+MtkCamMsgExtDataHelper::
+~MtkCamMsgExtDataHelper()
+{
+    uninit();
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+init(const sp<IMemory>& dataPtr)
+{
+    bool ret = false;
+    //
+    sp<IMemoryHeap> heap = 0;
+    ssize_t         offset = 0;
+    size_t          size = 0;
+    //
+    if  ( NULL == dataPtr.get() ) {
+        ALOGE("[MtkCamMsgExtDataHelper] dataPtr is NULL \r\n");
+        goto lbExit;
+    }
+    //
+    heap = dataPtr->getMemory(&offset, &size);
+    if  ( NULL == heap.get() || NULL == heap->base() ) {
+        ALOGE("[MtkCamMsgExtDataHelper] heap or heap->base() is NULL - (heap,offset,size)=(%p,%ld,%d) \r\n", heap.get(), offset, size);
+        goto lbExit;
+    }
+    //
+    if ( sizeof(DataHeader) > size ) {
+        ALOGE("[MtkCamMsgExtDataHelper] sizeof(DataHeader)(%d) > size(%d) \r\n", sizeof(DataHeader), size);
+        goto lbExit;
+    }
+    //
+    ::memcpy(&mExtDataHdr, ((uint8_t*)heap->base()) + offset, sizeof(DataHeader));
+    mspData = dataPtr;
+    mspHeap = heap;
+    mDataOffset = offset;
+    mDataSize   = size;
+    mIsValid= true;
+    ret = true;
+lbExit:
+    return  ret;
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+uninit()
+{
+    mIsValid= false;
+    mspData = NULL;
+    mspHeap = NULL;
+    mDataOffset = 0;
+    mDataSize   = 0;
+    ::memset(&mExtDataHdr, 0, sizeof(mExtDataHdr));
+    return  true;
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+create(size_t const extParamSize, uint32_t const u4ExtMsgType)
+{
+    bool ret = false;
+    //
+    size_t const extDataSize = sizeof(DataHeader) + extParamSize;
+    sp<IMemoryHeap> heap = 0;
+    sp<IMemory> dataPtr = 0;
+
+    //  (1) Check arguments.
+    if  ( 0 == extParamSize )
+    {
+        ALOGW("[MtkCamMsgExtDataHelper::create] extParamSize==0 \r\n");
+    }
+
+    //  (2) Allocate memory
+    heap = new MemoryHeapBase(extDataSize, 0, NULL);
+    dataPtr = new MemoryBase(heap, 0, extDataSize);
+
+    //  (3) Initialize.
+    ret = init(dataPtr);
+    if  ( ! ret )
+    {
+        ALOGE("[MtkCamMsgExtDataHelper::create] init fail \r\n");
+        goto lbExit;
+    }
+
+    //  (4) Assign the header.
+    mExtDataHdr.extMsgType = u4ExtMsgType;
+    ::memcpy(((uint8_t*)mspHeap->base()) + mDataOffset, &mExtDataHdr, sizeof(DataHeader));
+
+    ret = true;
+lbExit:
+    return  ret;
+}
+
+
+bool
+MtkCamMsgExtDataHelper::
+destroy()
+{
+    return  uninit();
+}
+
+
+uint8_t*
+MtkCamMsgExtDataHelper::
+getExtParamBase() const
+{
+    return  mIsValid
+        ?   static_cast<uint8_t*>(mspHeap->base()) + mDataOffset + sizeof(DataHeader)
+        :   NULL;
+}
+
+
+size_t
+MtkCamMsgExtDataHelper::
+getExtParamSize() const
+{
+    return  mIsValid
+        ?   (mDataSize - sizeof(DataHeader))
+        :   0;
+}
+
+
+ssize_t
+MtkCamMsgExtDataHelper::
+getExtParamOffset() const
+{
+    return  mIsValid
+        ?   (mDataOffset + sizeof(DataHeader))
+        :   0;
+}
+
+
+}; // namespace android
diff --git a/camera/mediatek/MtkCameraParameters.cpp b/camera/mediatek/MtkCameraParameters.cpp
new file mode 100644
index 000000000..fd2a71771
--- /dev/null
+++ b/camera/mediatek/MtkCameraParameters.cpp
@@ -0,0 +1,308 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+**
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "MTKCameraParams"
+#include <utils/Log.h>
+
+#include <string.h>
+#include <stdlib.h>
+#include <camera/MtkCameraParameters.h>
+
+namespace android {
+
+
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  App Mode.
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+const char MtkCameraParameters::PROPERTY_KEY_CLIENT_APPMODE[]   = "client.appmode";
+//
+const char MtkCameraParameters::APP_MODE_NAME_DEFAULT[]         = "Default";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_ENG[]         = "MtkEng";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_ATV[]         = "MtkAtv";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_S3D[]         = "MtkS3d";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_VT[]          = "MtkVt";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_PHOTO[]       = "MtkPhoto";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_VIDEO[]       = "MtkVideo";
+const char MtkCameraParameters::APP_MODE_NAME_MTK_ZSD[]         = "MtkZsd";
+
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Scene Mode
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+const char MtkCameraParameters::SCENE_MODE_NORMAL[] = "normal";
+
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Face Beauty
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+const char MtkCameraParameters::KEY_FB_SMOOTH_LEVEL[]       = "fb-smooth-level";
+const char MtkCameraParameters::KEY_FB_SMOOTH_LEVEL_MIN[]   = "fb-smooth-level-min";
+const char MtkCameraParameters::KEY_FB_SMOOTH_LEVEL_MAX[]   = "fb-smooth-level-max";
+//
+const char MtkCameraParameters::KEY_FB_SKIN_COLOR[]         = "fb-skin-color";
+const char MtkCameraParameters::KEY_FB_SKIN_COLOR_MIN[]     = "fb-skin-color-min";
+const char MtkCameraParameters::KEY_FB_SKIN_COLOR_MAX[]     = "fb-skin-color-max";
+//
+const char MtkCameraParameters::KEY_FB_SHARP[]              = "fb-sharp";
+const char MtkCameraParameters::KEY_FB_SHARP_MIN[]          = "fb-sharp-min";
+const char MtkCameraParameters::KEY_FB_SHARP_MAX[]          = "fb-sharp-max";
+
+
+//
+const char MtkCameraParameters::KEY_EXPOSURE[] = "exposure";
+const char MtkCameraParameters::KEY_EXPOSURE_METER[] = "exposure-meter";
+const char MtkCameraParameters::KEY_ISO_SPEED[] = "iso-speed";
+const char MtkCameraParameters::KEY_AE_MODE[] = "ae-mode";
+const char MtkCameraParameters::KEY_FOCUS_METER[] = "focus-meter";
+const char MtkCameraParameters::KEY_EDGE[] = "edge";
+const char MtkCameraParameters::KEY_HUE[] = "hue";
+const char MtkCameraParameters::KEY_SATURATION[] = "saturation";
+const char MtkCameraParameters::KEY_BRIGHTNESS[] = "brightness";
+const char MtkCameraParameters::KEY_CONTRAST[] = "contrast";
+const char MtkCameraParameters::KEY_AF_LAMP_MODE [] = "aflamp-mode";
+const char MtkCameraParameters::KEY_STEREO_3D_PREVIEW_SIZE[] = "stereo3d-preview-size";
+const char MtkCameraParameters::KEY_STEREO_3D_PICTURE_SIZE[] = "stereo3d-picture-size";
+const char MtkCameraParameters::KEY_STEREO_3D_TYPE [] = "stereo3d-type";
+const char MtkCameraParameters::KEY_STEREO_3D_MODE [] = "stereo3d-mode";
+const char MtkCameraParameters::KEY_STEREO_3D_IMAGE_FORMAT [] = "stereo3d-image-format";
+
+// ZSD
+const char MtkCameraParameters::KEY_ZSD_MODE[] = "zsd-mode";
+const char MtkCameraParameters::KEY_SUPPORTED_ZSD_MODE[] = "zsd-supported";
+//
+const char MtkCameraParameters::KEY_FPS_MODE[] = "fps-mode";
+//
+const char MtkCameraParameters::KEY_FOCUS_DRAW[] = "af-draw";
+//
+const char MtkCameraParameters::KEY_CAPTURE_MODE[] = "cap-mode";
+const char MtkCameraParameters::KEY_SUPPORTED_CAPTURE_MODES[] = "cap-mode-values";
+const char MtkCameraParameters::KEY_CAPTURE_PATH[] = "capfname";
+const char MtkCameraParameters::KEY_BURST_SHOT_NUM[] = "burst-num";
+//
+const char MtkCameraParameters::KEY_MATV_PREVIEW_DELAY[] = "tv-delay";
+const char MtkCameraParameters::KEY_PANORAMA_IDX[] = "pano-idx";
+const char MtkCameraParameters::KEY_PANORAMA_DIR[] = "pano-dir";
+
+// Values for KEY_EXPOSURE
+const char MtkCameraParameters::EXPOSURE_METER_SPOT[] = "spot";
+const char MtkCameraParameters::EXPOSURE_METER_CENTER[] = "center";
+const char MtkCameraParameters::EXPOSURE_METER_AVERAGE[] = "average";
+
+// Valeus for KEY_ISO_SPEED
+const char MtkCameraParameters::ISO_SPEED_AUTO[] = "auto";
+const char MtkCameraParameters::ISO_SPEED_100[] = "100";
+const char MtkCameraParameters::ISO_SPEED_200[] = "200";
+const char MtkCameraParameters::ISO_SPEED_400[] = "400";
+const char MtkCameraParameters::ISO_SPEED_800[] = "800";
+const char MtkCameraParameters::ISO_SPEED_1600[] = "1600";
+
+// Values for KEY_AE_MODE = "ae-mode"
+
+// Values for KEY_FOCUS_METER
+const char MtkCameraParameters::FOCUS_METER_SPOT[] = "spot";
+const char MtkCameraParameters::FOCUS_METER_MULTI[] = "multi";
+
+// AWB2PASS
+const char MtkCameraParameters::KEY_AWB2PASS[] = "awb-2pass";
+
+
+//
+//  Camera Mode
+const char MtkCameraParameters::KEY_CAMERA_MODE[] = "mtk-cam-mode";
+// Values for KEY_CAMERA_MODE
+const int MtkCameraParameters::CAMERA_MODE_NORMAL  = 0;
+const int MtkCameraParameters::CAMERA_MODE_MTK_PRV = 1;
+const int MtkCameraParameters::CAMERA_MODE_MTK_VDO = 2;
+const int MtkCameraParameters::CAMERA_MODE_MTK_VT  = 3;
+
+// Values for KEY_FPS_MODE
+const int MtkCameraParameters::FPS_MODE_NORMAL = 0;
+const int MtkCameraParameters::FPS_MODE_FIX = 1;
+
+// Values for raw save mode
+
+// Values for KEY_FOCUS_DRAW
+
+// Values for capture mode
+const char MtkCameraParameters::CAPTURE_MODE_PANORAMA_SHOT[] = "panoramashot";
+const char MtkCameraParameters::CAPTURE_MODE_BURST_SHOT[] = "burstshot";
+const char MtkCameraParameters::CAPTURE_MODE_NORMAL[] = "normal";
+const char MtkCameraParameters::CAPTURE_MODE_BEST_SHOT[] = "bestshot";
+const char MtkCameraParameters::CAPTURE_MODE_EV_BRACKET_SHOT[] = "evbracketshot";
+const char MtkCameraParameters::CAPTURE_MODE_SMILE_SHOT[] = "smileshot";
+const char MtkCameraParameters::CAPTURE_MODE_MAV_SHOT[] = "mav";
+const char MtkCameraParameters::CAPTURE_MODE_AUTO_PANORAMA_SHOT[] = "autorama";
+const char MtkCameraParameters::CAPTURE_MODE_MOTION_TRACK_SHOT[] = "motiontrack";
+const char MtkCameraParameters::CAPTURE_MODE_HDR_SHOT[] = "hdr";
+const char MtkCameraParameters::CAPTURE_MODE_ASD_SHOT[] = "asd";
+const char MtkCameraParameters::CAPTURE_MODE_ZSD_SHOT[] = "zsd";
+const char MtkCameraParameters::CAPTURE_MODE_PANO_3D[] = "pano_3d";
+const char MtkCameraParameters::CAPTURE_MODE_SINGLE_3D[] = "single_3d";
+const char MtkCameraParameters::CAPTURE_MODE_FACE_BEAUTY[] = "face_beauty";
+const char MtkCameraParameters::CAPTURE_MODE_CONTINUOUS_SHOT[] = "continuousshot";
+const char MtkCameraParameters::CAPTURE_MODE_MULTI_MOTION[] = "multi_motion";
+const char MtkCameraParameters::CAPTURE_MODE_GESTURE_SHOT[] = "gestureshot";
+
+// Values for panorama direction settings
+const char MtkCameraParameters::PANORAMA_DIR_RIGHT[] = "right";
+const char MtkCameraParameters::PANORAMA_DIR_LEFT[] = "left";
+const char MtkCameraParameters::PANORAMA_DIR_TOP[] = "top";
+const char MtkCameraParameters::PANORAMA_DIR_DOWN[] = "down";
+
+//
+const int MtkCameraParameters::ENABLE = 1;
+const int MtkCameraParameters::DISABLE = 0;
+
+// Values for KEY_EDGE, KEY_HUE, KEY_SATURATION, KEY_BRIGHTNESS, KEY_CONTRAST
+const char MtkCameraParameters::HIGH[] = "high";
+const char MtkCameraParameters::MIDDLE[] = "middle";
+const char MtkCameraParameters::LOW[] = "low";
+
+// Preview Internal Format.
+const char MtkCameraParameters::KEY_PREVIEW_INT_FORMAT[] = "prv-int-fmt";
+
+// Pixel color formats for KEY_PREVIEW_FORMAT, KEY_PICTURE_FORMAT,
+// and KEY_VIDEO_FRAME_FORMAT
+const char MtkCameraParameters::PIXEL_FORMAT_YUV420I[] = "yuv420i-yyuvyy-3plane";
+const char MtkCameraParameters::PIXEL_FORMAT_YV12_GPU[] = "yv12-gpu";
+const char MtkCameraParameters::PIXEL_FORMAT_YUV422I_UYVY[] = "yuv422i-uyvy";
+const char MtkCameraParameters::PIXEL_FORMAT_YUV422I_VYUY[] = "yuv422i-vyuy";
+const char MtkCameraParameters::PIXEL_FORMAT_YUV422I_YVYU[] = "yuv422i-yvyu";
+
+const char MtkCameraParameters::PIXEL_FORMAT_BAYER8[] = "bayer8";
+const char MtkCameraParameters::PIXEL_FORMAT_BAYER10[] = "bayer10";
+
+const char MtkCameraParameters::KEY_BRIGHTNESS_VALUE[] = "brightness_value";
+
+// ISP Operation mode for meta mode use
+const char MtkCameraParameters::KEY_ISP_MODE[] = "isp-mode";
+// AF
+const char MtkCameraParameters::KEY_AF_X[] = "af-x";
+const char MtkCameraParameters::KEY_AF_Y[] = "af-y";
+// Effect
+const char MtkCameraParameters::EFFECT_SEPIA_BLUE[] = "sepiablue";
+const char MtkCameraParameters::EFFECT_SEPIA_GREEN[] = "sepiagreen";
+
+//
+//  on/off => FIXME: should be replaced with TRUE[]
+const char MtkCameraParameters::ON[] = "on";
+const char MtkCameraParameters::OFF[] = "off";
+//
+const char MtkCameraParameters::WHITE_BALANCE_TUNGSTEN[] = "tungsten";
+//
+const char MtkCameraParameters::ISO_SPEED_ENG[] = "iso-speed-eng";
+const char MtkCameraParameters::KEY_RAW_SAVE_MODE[] = "rawsave-mode";
+const char MtkCameraParameters::KEY_RAW_PATH[] = "rawfname";
+
+const char MtkCameraParameters::KEY_FAST_CONTINUOUS_SHOT[] = "fast-continuous-shot";
+
+const char MtkCameraParameters::KEY_CSHOT_INDICATOR[] = "cshot-indicator";
+
+// AF EM MODE
+const char MtkCameraParameters::KEY_FOCUS_ENG_MODE[]		= "afeng-mode";
+const char MtkCameraParameters::KEY_FOCUS_ENG_STEP[] 		= "afeng-pos";
+const char MtkCameraParameters::KEY_FOCUS_ENG_MAX_STEP[] 	= "afeng-max-focus-step";
+const char MtkCameraParameters::KEY_FOCUS_ENG_MIN_STEP[] 	= "afeng-min-focus-step";
+const char MtkCameraParameters::KEY_FOCUS_ENG_BEST_STEP[]   = "afeng-best-focus-step";
+const char MtkCameraParameters::KEY_RAW_DUMP_FLAG[]         = "afeng_raw_dump_flag";
+const char MtkCameraParameters::KEY_PREVIEW_DUMP_RESOLUTION[] = "preview-dump-resolution";
+// Values for KEY_PREVIEW_DUMP_RESOLUTION
+const int MtkCameraParameters::PREVIEW_DUMP_RESOLUTION_NORMAL  = 0;
+const int MtkCameraParameters::PREVIEW_DUMP_RESOLUTION_CROP  = 1;
+//
+const char MtkCameraParameters::KEY_MAX_NUM_DETECTED_OBJECT[] = "max-num-ot";
+//
+const char MtkCameraParameters::KEY_VIDEO_HDR[] = "video-hdr";
+
+// KEY for [Engineer Mode] Add new camera paramters for new requirements
+const char MtkCameraParameters::KEY_ENG_AE_ENABLE[] = "eng-ae-enable";
+const char MtkCameraParameters::KEY_ENG_PREVIEW_SHUTTER_SPEED[] = "eng-preview-shutter-speed";
+const char MtkCameraParameters::KEY_ENG_PREVIEW_SENSOR_GAIN[] = "eng-preview-sensor-gain";
+const char MtkCameraParameters::KEY_ENG_PREVIEW_ISP_GAIN[] = "eng-preview-isp-gain";
+const char MtkCameraParameters::KEY_ENG_PREVIEW_AE_INDEX[] = "eng-preview-ae-index";
+const char MtkCameraParameters::KEY_ENG_CAPTURE_SENSOR_GAIN[] = "eng-capture-sensor-gain";
+const char MtkCameraParameters::KEY_ENG_CAPTURE_ISP_GAIN[] = "eng-capture-isp-gain";
+const char MtkCameraParameters::KEY_ENG_CAPTURE_SHUTTER_SPEED[] = "eng-capture-shutter-speed";
+const char MtkCameraParameters::KEY_ENG_CAPTURE_ISO[] = "eng-capture-iso";
+const char MtkCameraParameters::KEY_ENG_FLASH_DUTY_VALUE[] = "eng-flash-duty-value";
+const char MtkCameraParameters::KEY_ENG_FLASH_DUTY_MIN[] = "eng-flash-duty-min";
+const char MtkCameraParameters::KEY_ENG_FLASH_DUTY_MAX[] = "eng-flash-duty-max";
+const char MtkCameraParameters::KEY_ENG_ZSD_ENABLE[] = "eng-zsd-enable";
+const char MtkCameraParameters::KEY_SENSOR_TYPE[] = "sensor-type";
+const char MtkCameraParameters::KEY_ENG_PREVIEW_FPS[] = "eng-preview-fps";
+const char MtkCameraParameters::KEY_ENG_MSG[] = "eng-msg";
+const int  MtkCameraParameters::KEY_ENG_FLASH_DUTY_DEFAULT_VALUE = -1;
+const int  MtkCameraParameters::KEY_ENG_FLASH_STEP_DEFAULT_VALUE = -1;
+const char MtkCameraParameters::KEY_ENG_FLASH_STEP_MIN[] = "eng-flash-step-min";
+const char MtkCameraParameters::KEY_ENG_FLASH_STEP_MAX[] = "eng-flash-step-max";
+const char MtkCameraParameters::KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL[] = "eng-focus-fullscan-frame-interval";
+const char MtkCameraParameters::KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX[] = "eng-focus-fullscan-frame-interval-max";
+const char MtkCameraParameters::KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN[] = "eng-focus-fullscan-frame-interval-min";
+const int  MtkCameraParameters::KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX_DEFAULT = 65535;
+const int  MtkCameraParameters::KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN_DEFAULT = 0;
+const char MtkCameraParameters::KEY_ENG_PREVIEW_FRAME_INTERVAL_IN_US[] = "eng-preview-frame-interval-in-us";
+const char MtkCameraParameters::KEY_ENG_PARAMETER1[] = "key-eng-parameter1";
+const char MtkCameraParameters::KEY_ENG_PARAMETER2[] = "key-eng-parameter2";
+const char MtkCameraParameters::KEY_ENG_PARAMETER3[] = "key-eng-parameter3";
+
+const char MtkCameraParameters::KEY_ENG_SAVE_SHADING_TABLE[] = "eng-save-shading-table";
+const char MtkCameraParameters::KEY_ENG_SHADING_TABLE[] = "eng-shading-table";
+const int MtkCameraParameters::KEY_ENG_SHADING_TABLE_AUTO = 0;
+const int MtkCameraParameters::KEY_ENG_SHADING_TABLE_LOW = 1;
+const int MtkCameraParameters::KEY_ENG_SHADING_TABLE_MIDDLE = 2;
+const int MtkCameraParameters::KEY_ENG_SHADING_TABLE_HIGH = 3;
+const int MtkCameraParameters::KEY_ENG_SHADING_TABLE_TSF = 4;
+
+// KEY for [Engineer Mode] Add new camera paramters for ev calibration
+const char MtkCameraParameters::KEY_ENG_EV_CALBRATION_OFFSET_VALUE[] = "eng-ev-cal-offset";
+
+}; // namespace android
diff --git a/include/camera/MtkCamera.h b/include/camera/MtkCamera.h
new file mode 100644
index 000000000..8982febe5
--- /dev/null
+++ b/include/camera/MtkCamera.h
@@ -0,0 +1,275 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_HARDWARE_MTK_CAMERA_H
+#define ANDROID_HARDWARE_MTK_CAMERA_H
+
+#include <binder/IMemory.h>
+
+namespace android {
+
+// extended msgType in notifyCallback and dataCallback functions
+enum {
+    MTK_CAMERA_MSG_EXT_NOTIFY       = 0x40000000,
+    MTK_CAMERA_MSG_EXT_DATA         = 0x80000000,
+};
+
+// extended notify message related to MTK_CAMERA_MSG_EXT_NOTIFY used in notifyCallback functions
+enum {
+    //
+    //  Smile Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_SMILE_DETECT      = 0x00000001,
+    //
+    //  Auto Scene Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_ASD               = 0x00000002,
+    //
+    //  Multi Angle View
+    MTK_CAMERA_MSG_EXT_NOTIFY_MAV               = 0x00000003,
+    //
+    // Burst Shutter Callback
+    //  ext2: count-down shutter number; 0: the last one shutter.
+    MTK_CAMERA_MSG_EXT_NOTIFY_BURST_SHUTTER     = 0x00000004,
+    //
+    // Continuous Shutter Callback
+    //  ext2: current continuous shutter number.
+    MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_SHUTTER= 0x00000005,
+    //
+    // Continuous EndCallback
+    MTK_CAMERA_MSG_EXT_NOTIFY_CONTINUOUS_END	= 0x00000006,
+
+    // ZSD preview done
+    MTK_CAMERA_MSG_EXT_NOTIFY_ZSD_PREVIEW_DONE = 0x00000007,
+    //
+    // Capture done (disable CAMERA_MSG_SHUTTER / CAMERA_MSG_COMPRESSED_IMAGE)
+    MTK_CAMERA_MSG_EXT_NOTIFY_CAPTURE_DONE      = 0x00000010,
+    //
+    // Shutter Callback (not disable CAMERA_MSG_SHUTTER)
+    //  ext2: 1: CameraService will play shutter sound.
+    MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER           = 0x00000011,
+    //
+    // for EM preview raw dump error notify
+    MTK_CAMERA_MSG_EXT_NOTIFY_RAW_DUMP_STOPPED  = 0x00000012,
+    //
+    // Gesture Detection
+    MTK_CAMERA_MSG_EXT_NOTIFY_GESTURE_DETECT  = 0x00000013
+};
+
+// extended data message related to MTK_CAMERA_MSG_EXT_DATA used in dataCallback functions
+// extended data header is located at the top of dataPrt in dataCallback functions
+//  DATA: Header + Params
+enum {
+    //
+    // Auto Panorama
+    //  Params:
+    //      int[0]: 0:mAUTORAMAMVCallback, 1:mAUTORAMACallback
+    //      int[1~]:depends on
+    //
+    MTK_CAMERA_MSG_EXT_DATA_AUTORAMA            = 0x00000001,
+    //
+    // AF Window Results
+    MTK_CAMERA_MSG_EXT_DATA_AF					= 0x00000002,
+    //
+    // Burst Shot (EV Shot)
+    //      int[0]: the total shut count.
+    //      int[1]: count-down shut number; 0: the last one shut.
+    MTK_CAMERA_MSG_EXT_DATA_BURST_SHOT          = 0x00000003,
+    //
+	//	Continuous Shot
+	//		int[0]: current continuous shut number.
+    MTK_CAMERA_MSG_EXT_DATA_CONTINUOUS_SHOT     = 0x00000004,
+
+
+    MTK_CAMERA_MSG_EXT_DATA_OT                  = 0x00000005,
+
+    //  Facebeauty Shot
+    //      int[0]: data type. 0:original image.
+    MTK_CAMERA_MSG_EXT_DATA_FACEBEAUTY          = 0x00000006,
+    //
+    //  MAV Shot
+    //      int[0]: data type. 0:original image.
+    MTK_CAMERA_MSG_EXT_DATA_MAV                 = 0x00000007,
+    //
+    //  HDR Shot
+    //      int[0]: data type. 0:0EV image.
+    MTK_CAMERA_MSG_EXT_DATA_HDR                 = 0x00000008,
+
+    //
+    // Motion Track
+    //  Params:
+    //      int[0]: 0: frame EIS, 1: captured image, 2: blended image, 3: intermediate data
+    //      int[1~]:depends on
+    //
+    MTK_CAMERA_MSG_EXT_DATA_MOTIONTRACK         = 0x00000009,
+
+    //
+    //  Compressed Image (not disable CAMERA_MSG_COMPRESSED_IMAGE)
+    //      int[0]: current shut index; 0: the first one shut.
+    MTK_CAMERA_MSG_EXT_DATA_COMPRESSED_IMAGE    = 0x00000010,
+};
+
+//  MTK-extended camera message data helper.
+//  DATA: Header + Params
+class MtkCamMsgExtDataHelper
+{
+public:
+    //  The header type of MTK-extended camera message data.
+    struct DataHeader {
+        uint32_t        extMsgType;
+    };
+
+public:
+    MtkCamMsgExtDataHelper();
+    ~MtkCamMsgExtDataHelper();
+    bool            init(const sp<IMemory>& dataPtr);
+    bool            uninit();
+    bool            create(size_t const extParamSize, uint32_t const u4ExtMsgType);
+    bool            destroy();
+
+    uint8_t*                        getExtParamBase() const;
+    size_t                          getExtParamSize() const;
+    ssize_t                         getExtParamOffset() const;
+    inline uint32_t                 getExtMsgType() const { return mExtDataHdr.extMsgType; }
+    inline DataHeader const&        getExtDataHeader() const { return mExtDataHdr; }
+    inline sp<IMemory>const&        getData() const { return mspData; }
+    inline sp<IMemoryHeap>const&    getHeap() const { return mspHeap; }
+
+protected:
+    bool            mIsValid;
+    sp<IMemory>     mspData;
+    sp<IMemoryHeap> mspHeap;
+    ssize_t         mDataOffset;
+    size_t          mDataSize;
+    DataHeader      mExtDataHdr;
+};
+
+
+// cmdType in sendCommand functions
+enum {
+    CAMERA_CMD_MTK_DEFINE_START     = 0x10000000,
+    CAMERA_CMD_DO_PANORAMA,
+    CAMERA_CMD_CANCEL_PANORAMA,
+    CAMERA_CMD_START_SD_PREVIEW,            //(Smile Detection)
+    CAMERA_CMD_CANCEL_SD_PREVIEW,           //(Smile Detection)
+    CAMERA_CMD_START_OT, 
+    CAMERA_CMD_STOP_OT,  
+    CAMERA_CMD_START_MAV,
+    CAMERA_CMD_STOP_MAV,
+    CAMERA_CMD_START_AUTORAMA,
+    CAMERA_CMD_STOP_AUTORAMA,
+    CAMERA_CMD_GET_MEM_INFO,                //For Video to get PMEM buffer info
+    CAMERA_CMD_GET_REC_BUF_INFO,
+    CAMERA_CMD_CANCEL_CSHOT,
+    CAMERA_CMD_SET_CSHOT_SPEED,
+#ifdef MTK_S3D_SUPPORT
+    CAMERA_CMD_START_3DSHOT,
+    CAMERA_CMD_STOP_3DSHOT,
+#endif
+    CAMERA_CMD_START_MOTIONTRACK,
+    CAMERA_CMD_STOP_MOTIONTRACK,
+    CAMERA_CMD_START_CLONECAMERA,
+    CAMERA_CMD_SHOT_CLONECAMERA,
+    CAMERA_CMD_STOP_CLONECAMERA,
+    CAMERA_CMD_START_GD_PREVIEW,            //(Gesture Detection)
+    CAMERA_CMD_CANCEL_GD_PREVIEW,           //(Gesture Detection)
+};
+
+/*
+ * For Video to get PMEM buffer info
+ *
+ * Command: CAMERA_CMD_GET_MEM_INFO
+ */
+struct CameraMemInfo {
+    enum { eTYPE_PMEM = 0 };
+    uint32_t    u4Type;
+    uint32_t    u4VABase;
+    uint32_t    u4PABase;
+    uint32_t    u4MemSize;
+    uint32_t    u4MemCount;
+};
+
+
+/*
+ *  set camera fatal errors enum
+ *
+ */
+enum {
+    CAMERA_ERROR_NO_MEMORY = 1000,
+    CAMERA_ERROR_RESET,
+};
+
+/*
+ * For Video to get buffer info
+ *
+ * Command: CAMERA_CMD_GET_REC_BUF_INFO
+ */
+struct CameraRecBufInfo {
+    int32_t     i4MemId;
+    uint32_t    u4VirAddr;
+    uint32_t    u4Size;
+};
+
+
+/*
+ * For Video to set setting
+ *
+ * Command: CAMERA_CMD_GET_REC_BUF_INFO
+ */
+struct CameraRecSetting {
+    int32_t     mi4BufSecu; //security
+    int32_t     mi4BufCohe; //coherent
+};
+
+
+}; // namespace android
+
+#endif  //ANDROID_HARDWARE_MTK_CAMERA_H
diff --git a/include/camera/MtkCameraParameters.h b/include/camera/MtkCameraParameters.h
new file mode 100644
index 000000000..4a349574d
--- /dev/null
+++ b/include/camera/MtkCameraParameters.h
@@ -0,0 +1,364 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_HARDWARE_MTK_CAMERA_PARAMETERS_H
+#define ANDROID_HARDWARE_MTK_CAMERA_PARAMETERS_H
+
+#include <camera/CameraParameters.h>
+
+namespace android {
+
+
+/**
+ * @class      MtkCameraParameters
+ * @brief      MTK-proprietary camera parameters.
+ * @details    This class is derived from CameraParameters and defines MTK-proprietary camera parameters.
+ */
+class MtkCameraParameters : public CameraParameters
+{
+public:
+    MtkCameraParameters() : CameraParameters() {}
+    MtkCameraParameters(const String8 &params) { unflatten(params); }
+    ~MtkCameraParameters()  {}
+
+    MtkCameraParameters& operator=(CameraParameters const& params)
+    {
+        unflatten(params.flatten());
+        return  (*this);
+    }
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  App Mode.
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char PROPERTY_KEY_CLIENT_APPMODE[];
+    //
+    static const char APP_MODE_NAME_DEFAULT[];
+    static const char APP_MODE_NAME_MTK_ENG[];
+    static const char APP_MODE_NAME_MTK_ATV[];
+    static const char APP_MODE_NAME_MTK_S3D[];
+    static const char APP_MODE_NAME_MTK_VT[];
+    static const char APP_MODE_NAME_MTK_PHOTO[];
+    static const char APP_MODE_NAME_MTK_VIDEO[];
+    static const char APP_MODE_NAME_MTK_ZSD[];
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Scene Mode
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char SCENE_MODE_NORMAL[];
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//  Face Beauty
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char KEY_FB_SMOOTH_LEVEL[];
+    static const char KEY_FB_SMOOTH_LEVEL_MIN[];
+    static const char KEY_FB_SMOOTH_LEVEL_MAX[];
+    //
+    static const char KEY_FB_SKIN_COLOR[];
+    static const char KEY_FB_SKIN_COLOR_MIN[];
+    static const char KEY_FB_SKIN_COLOR_MAX[];
+    //
+    static const char KEY_FB_SHARP[];
+    static const char KEY_FB_SHARP_MIN[];
+    static const char KEY_FB_SHARP_MAX[];
+    //
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+    static const char KEY_EXPOSURE[];
+    static const char KEY_EXPOSURE_METER[];
+    static const char KEY_ISO_SPEED[];
+    static const char KEY_AE_MODE[];
+    static const char KEY_FOCUS_METER[];
+    static const char KEY_EDGE[];
+    static const char KEY_HUE[];
+    static const char KEY_SATURATION[];
+    static const char KEY_BRIGHTNESS[];
+    static const char KEY_CONTRAST[];
+    static const char KEY_ZSD_MODE[];
+    static const char KEY_SUPPORTED_ZSD_MODE[];
+    static const char KEY_AWB2PASS[];
+    static const char KEY_AF_LAMP_MODE [];
+
+    static const char KEY_STEREO_3D_PREVIEW_SIZE[];
+    static const char KEY_STEREO_3D_PICTURE_SIZE[];
+    static const char KEY_STEREO_3D_TYPE [];
+    static const char KEY_STEREO_3D_MODE [];
+    static const char KEY_STEREO_3D_IMAGE_FORMAT [];
+    //
+    static const char KEY_FPS_MODE[];       // normal,fix
+    //
+    static const char KEY_FOCUS_DRAW[];     // 0,1
+    //
+    static const char KEY_CAPTURE_MODE[];   // normal,bestshot,evbracketshot,burstshot,smileshot,panoramashot
+    static const char KEY_SUPPORTED_CAPTURE_MODES[];
+    static const char KEY_CAPTURE_PATH[];
+    static const char KEY_BURST_SHOT_NUM[];
+    //
+    static const char KEY_MATV_PREVIEW_DELAY[];
+    //
+    static const char KEY_PANORAMA_IDX[];
+    static const char KEY_PANORAMA_DIR[];   // right,left,top,bottom
+    //
+    static const char KEY_SENSOR_DEV[];    // main,sub,atv
+    static const char KEY_SUPPORTED_SENSOR_DEVS[];
+
+    // Values for KEY_EXPOSURE
+    static const char EXPOSURE_METER_SPOT[];
+    static const char EXPOSURE_METER_CENTER[];
+    static const char EXPOSURE_METER_AVERAGE[];
+
+    // Valeus for KEY_ISO_SPEED
+    static const char ISO_SPEED_AUTO[];
+    static const char ISO_SPEED_100[];
+    static const char ISO_SPEED_200[];
+    static const char ISO_SPEED_400[];
+    static const char ISO_SPEED_800[];
+    static const char ISO_SPEED_1600[];
+
+    // Values for KEY_FOCUS_METER
+    static const char FOCUS_METER_SPOT[];
+    static const char FOCUS_METER_MULTI[];
+
+    static const char KEY_CAMERA_MODE[];
+    // Values for KEY_CAMERA_MODE
+    static const int CAMERA_MODE_NORMAL;
+    static const int CAMERA_MODE_MTK_PRV;
+    static const int CAMERA_MODE_MTK_VDO;
+    static const int CAMERA_MODE_MTK_VT;
+
+    // Values for KEY_FPS_MODE
+    static const int FPS_MODE_NORMAL;
+    static const int FPS_MODE_FIX;
+
+    // Values for KEY_CAPTURE_MODE
+    static const char CAPTURE_MODE_PANORAMA_SHOT[];
+    static const char CAPTURE_MODE_BURST_SHOT[];
+    static const char CAPTURE_MODE_NORMAL[];
+    static const char CAPTURE_MODE_BEST_SHOT[];
+    static const char CAPTURE_MODE_EV_BRACKET_SHOT[];
+    static const char CAPTURE_MODE_SMILE_SHOT[];
+    static const char CAPTURE_MODE_AUTO_PANORAMA_SHOT[];
+    static const char CAPTURE_MODE_MOTION_TRACK_SHOT[];
+    static const char CAPTURE_MODE_MAV_SHOT[];
+    static const char CAPTURE_MODE_HDR_SHOT[];
+    static const char CAPTURE_MODE_ASD_SHOT[];
+    static const char CAPTURE_MODE_ZSD_SHOT[];
+    static const char CAPTURE_MODE_PANO_3D[];
+    static const char CAPTURE_MODE_SINGLE_3D[];
+    static const char CAPTURE_MODE_FACE_BEAUTY[];
+    static const char CAPTURE_MODE_CONTINUOUS_SHOT[];
+    static const char CAPTURE_MODE_MULTI_MOTION[];
+    static const char CAPTURE_MODE_GESTURE_SHOT[];
+
+    // Values for KEY_PANORAMA_DIR
+    static const char PANORAMA_DIR_RIGHT[];
+    static const char PANORAMA_DIR_LEFT[];
+    static const char PANORAMA_DIR_TOP[];
+    static const char PANORAMA_DIR_DOWN[];
+    //
+    static const int ENABLE;
+    static const int DISABLE;
+
+    // Values for KEY_EDGE, KEY_HUE, KEY_SATURATION, KEY_BRIGHTNESS, KEY_CONTRAST
+    static const char HIGH[];
+    static const char MIDDLE[];
+    static const char LOW[];
+
+    // Preview Internal Format.
+    static const char KEY_PREVIEW_INT_FORMAT[];
+
+    // Pixel color formats for KEY_PREVIEW_FORMAT, KEY_PICTURE_FORMAT,
+    // and KEY_VIDEO_FRAME_FORMAT
+    static const char PIXEL_FORMAT_YUV420I[]; // I420
+
+    /**
+     * @var PIXEL_FORMAT_YV12_GPU
+     *
+     * GPU YUV format:
+     *
+     * YV12 is a 4:2:0 YCrCb planar format comprised of a WxH Y plane followed
+     * by (W/2) x (H/2) Cr and Cb planes.
+     *
+     * This format assumes
+     * - an even width
+     * - an even height
+     * - a vertical stride equal to the height
+     * - a horizontal stride multiple of 32/16/16 pixels for y/cr/cb respectively
+     *   i.e.
+     *   y_stride = ALIGN(width, 32)
+     *   c_stride = y_stride / 2
+     *
+     *   y_size = y_stride * height
+     *   c_size = c_stride * height / 2
+     *   size = y_size + c_size * 2
+     *   cr_offset = y_size
+     *   cb_offset = y_size + c_size
+     *
+     *   for example:
+     *      width/height = 176x144
+     *      y stride     = 192x144
+     *      cr stride    = 96x72
+     *      cb stride    = 96x72
+     *
+     */
+    static const char PIXEL_FORMAT_YV12_GPU[];
+
+    /*
+     *  YUV422 format, 1 plane (UYVY)
+     *
+     *  Effective bits per pixel : 16
+     *
+     *  Y sample at every pixel, U and V sampled at every second pixel horizontally on each line.
+     *  A macropixel contains 2 pixels in 1 uint32_t.
+     *
+     */
+    static const char PIXEL_FORMAT_YUV422I_UYVY[];
+    //
+    static const char PIXEL_FORMAT_YUV422I_VYUY[];
+    static const char PIXEL_FORMAT_YUV422I_YVYU[];
+    static const char PIXEL_FORMAT_BAYER8[];
+    static const char PIXEL_FORMAT_BAYER10[];
+
+    /**
+     * @var KEY_BRIGHTNESS_VALUE
+     *
+     * This is a key string of brightness value, scaled by 10.
+     *
+     */
+    static const char KEY_BRIGHTNESS_VALUE[];
+
+    // ISP Operation mode for meta mode use
+    static const char KEY_ISP_MODE[];
+    // AF
+    static const char KEY_AF_X[];
+    static const char KEY_AF_Y[];
+    static const char KEY_FOCUS_ENG_MAX_STEP[];
+    static const char KEY_FOCUS_ENG_MIN_STEP[];
+    static const char KEY_FOCUS_ENG_BEST_STEP[];
+    static const char KEY_RAW_DUMP_FLAG[];
+    static const char KEY_PREVIEW_DUMP_RESOLUTION[];
+    static const int  PREVIEW_DUMP_RESOLUTION_NORMAL;
+    static const int  PREVIEW_DUMP_RESOLUTION_CROP;
+
+    // Values for effect
+    static const char EFFECT_SEPIA_BLUE[];
+    static const char EFFECT_SEPIA_GREEN[];
+    // Values for AWB
+    static const char WHITE_BALANCE_TUNGSTEN[];
+    // Eng
+    static const char ISO_SPEED_ENG[];
+    static const char KEY_FOCUS_ENG_MODE[]; // 0,1,2,3 (0: normal)
+    static const char KEY_FOCUS_ENG_STEP[];
+    static const char KEY_RAW_SAVE_MODE[];  // on, off
+    static const char KEY_RAW_PATH[];
+
+	// KEY for Continuous shot speed
+    static const char KEY_FAST_CONTINUOUS_SHOT[];
+
+    static const char KEY_VIDEO_HDR[];
+
+    static const char KEY_MAX_NUM_DETECTED_OBJECT[];
+
+    // KEY for c_shot indicator
+    static const char KEY_CSHOT_INDICATOR[];
+
+    // KEY for [Engineer Mode] Add new camera paramters for new requirements
+    static const char KEY_ENG_AE_ENABLE[];
+    static const char KEY_ENG_PREVIEW_SHUTTER_SPEED[];
+    static const char KEY_ENG_PREVIEW_SENSOR_GAIN[];
+    static const char KEY_ENG_PREVIEW_ISP_GAIN[];
+    static const char KEY_ENG_PREVIEW_AE_INDEX[];
+    static const char KEY_ENG_CAPTURE_SENSOR_GAIN[];
+    static const char KEY_ENG_CAPTURE_ISP_GAIN[];
+    static const char KEY_ENG_CAPTURE_SHUTTER_SPEED[];
+    static const char KEY_ENG_CAPTURE_ISO[];
+    static const char KEY_ENG_FLASH_DUTY_VALUE[];
+    static const char KEY_ENG_FLASH_DUTY_MIN[];
+    static const char KEY_ENG_FLASH_DUTY_MAX[];
+    static const char KEY_ENG_ZSD_ENABLE[];
+    static const char KEY_SENSOR_TYPE[];
+    static const char KEY_ENG_PREVIEW_FPS[];
+    static const char KEY_ENG_MSG[];
+    static const int  KEY_ENG_FLASH_DUTY_DEFAULT_VALUE;
+    static const int  KEY_ENG_FLASH_STEP_DEFAULT_VALUE;
+    static const char KEY_ENG_FLASH_STEP_MIN[];
+    static const char KEY_ENG_FLASH_STEP_MAX[];
+    static const char KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL[];
+    static const char KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX[];
+    static const char KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN[];
+    static const int  KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MAX_DEFAULT;
+    static const int  KEY_ENG_FOCUS_FULLSCAN_FRAME_INTERVAL_MIN_DEFAULT;
+    static const char KEY_ENG_PREVIEW_FRAME_INTERVAL_IN_US[];
+    static const char KEY_ENG_PARAMETER1[];
+    static const char KEY_ENG_PARAMETER2[];
+    static const char KEY_ENG_PARAMETER3[];
+
+    static const char KEY_ENG_SAVE_SHADING_TABLE[];
+    static const char KEY_ENG_SHADING_TABLE[];
+    static const int KEY_ENG_SHADING_TABLE_AUTO;
+    static const int KEY_ENG_SHADING_TABLE_LOW;
+    static const int KEY_ENG_SHADING_TABLE_MIDDLE;
+    static const int KEY_ENG_SHADING_TABLE_HIGH;
+    static const int KEY_ENG_SHADING_TABLE_TSF;
+
+    // KEY for [Engineer Mode] Add new camera paramters for ev calibration
+    static const char KEY_ENG_EV_CALBRATION_OFFSET_VALUE[];
+
+public:     //// on/off => FIXME: should be replaced with TRUE[]
+    static const char ON[];
+    static const char OFF[];
+};
+
+}; // namespace android
+
+#endif
diff --git a/include/media/MediaPlayerInterface.h b/include/media/MediaPlayerInterface.h
index 4810b7eef..e2fb54d1a 100644
--- a/include/media/MediaPlayerInterface.h
+++ b/include/media/MediaPlayerInterface.h
@@ -52,6 +52,9 @@ enum player_type {
     // argument to the 'test:' url in the setDataSource call.
     TEST_PLAYER = 5,
     DASH_PLAYER = 6,
+#ifdef MTK_HARDWARE
+    FM_AUDIO_PLAYER = 7,
+#endif
 };
 
 
diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index 0ac13b97c..2134cf5d1 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -297,6 +297,9 @@ struct ACodec : public AHierarchicalStateMachine, public CodecBase {
 #ifdef USE_SAMSUNG_COLORFORMAT
     void setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat);
 #endif
+#ifdef MTK_HARDWARE
+    void setHalWindowColorFormat(OMX_COLOR_FORMATTYPE &eHalColorFormat);
+#endif
     status_t cancelBufferToNativeWindow(BufferInfo *info);
     status_t freeOutputBuffersNotOwnedByComponent();
     BufferInfo *dequeueBufferFromNativeWindow();
diff --git a/include/media/stagefright/ColorConverter.h b/include/media/stagefright/ColorConverter.h
index 85ba92068..a914dcd1e 100644
--- a/include/media/stagefright/ColorConverter.h
+++ b/include/media/stagefright/ColorConverter.h
@@ -79,6 +79,10 @@ struct ColorConverter {
     status_t convertTIYUV420PackedSemiPlanar(
             const BitmapParams &src, const BitmapParams &dst);
 
+#ifdef MTK_HARDWARE
+    status_t convertYUVToRGBHW(const BitmapParams &src, const BitmapParams &dst);
+#endif
+
     ColorConverter(const ColorConverter &);
     ColorConverter &operator=(const ColorConverter &);
 };
diff --git a/include/media/stagefright/MediaSync.h b/include/media/stagefright/MediaSync.h
index ef8cb23d7..b8819a7f2 100644
--- a/include/media/stagefright/MediaSync.h
+++ b/include/media/stagefright/MediaSync.h
@@ -19,6 +19,7 @@
 
 #include <gui/IConsumerListener.h>
 #include <gui/IProducerListener.h>
+#include <gui/BufferQueue.h>
 
 #include <media/AudioResamplerPublic.h>
 #include <media/AVSyncSettings.h>
@@ -205,7 +206,7 @@ class MediaSync : public AHandler {
     bool mHasAudio;
 
     int64_t mNextBufferItemMediaUs;
-    List<BufferItem> mBufferItems;
+    List<BufferQueue::BufferItem> mBufferItems;
     sp<VideoFrameScheduler> mFrameScheduler;
 
     // Keep track of buffers received from |mInput|. This is needed because
@@ -248,7 +249,7 @@ class MediaSync : public AHandler {
     void onFrameAvailableFromInput();
 
     // Send |bufferItem| to the output for rendering.
-    void renderOneBufferItem_l(const BufferItem &bufferItem);
+    void renderOneBufferItem_l(const BufferQueue::BufferItem &bufferItem);
 
     // This implements the onBufferReleased callback from IProducerListener.
     // It gets called from an OutputListener.
diff --git a/include/media/stagefright/OMXCodec.h b/include/media/stagefright/OMXCodec.h
index 2f73de83d..32c4d6a72 100644
--- a/include/media/stagefright/OMXCodec.h
+++ b/include/media/stagefright/OMXCodec.h
@@ -294,6 +294,10 @@ struct OMXCodec : public MediaSource,
     status_t allocateBuffersOnPort(OMX_U32 portIndex);
     status_t allocateOutputBuffersFromNativeWindow();
 
+#ifdef MTK_HARDWARE
+    void setHalWindowColorFormat(OMX_COLOR_FORMATTYPE &eHalColorFormat);
+#endif
+
     status_t queueBufferToNativeWindow(BufferInfo *info);
     status_t cancelBufferToNativeWindow(BufferInfo *info);
     BufferInfo* dequeueBufferFromNativeWindow();
diff --git a/include/media/stagefright/dpframework/DpBlitStream.h b/include/media/stagefright/dpframework/DpBlitStream.h
new file mode 100644
index 000000000..57fd482d6
--- /dev/null
+++ b/include/media/stagefright/dpframework/DpBlitStream.h
@@ -0,0 +1,243 @@
+#ifndef __DP_BLIT_STREAM_H__
+#define __DP_BLIT_STREAM_H__
+
+#include "DpDataType.h"
+
+enum
+{
+    DP_BLIT_GENERAL_USER = 0,
+    DP_BLIT_HWC0 = 0,
+    DP_BLIT_GPU = 1,
+    DP_BLIT_HWC1 = 1,
+    DP_BLIT_HWC2 = 2,
+    DP_BLIT_HWC3 = 3
+};
+
+
+class DpBlitStream
+{
+public:
+    static bool queryHWSupport(uint32_t srcWidth,
+                               uint32_t srcHeight,
+                               uint32_t dstWidth,
+                               uint32_t dstHeight,
+                               int32_t  Orientation = 0);
+
+    DpBlitStream();
+
+    ~DpBlitStream();
+
+    enum DpOrientation
+    {
+        ROT_0   = 0x00000000,
+        FLIP_H  = 0x00000001,
+        FLIP_V  = 0x00000002,
+        ROT_90  = 0x00000004,
+        ROT_180 = FLIP_H|FLIP_V,
+        ROT_270 = ROT_180|ROT_90,
+        ROT_INVALID = 0x80
+    };
+
+    DP_STATUS_ENUM setSrcBuffer(void     *pVABase,
+                                uint32_t size);
+
+    DP_STATUS_ENUM setSrcBuffer(void     **pVAList,
+                                uint32_t *pSizeList,
+                                uint32_t planeNumber);
+
+    // VA + MVA address interface
+    DP_STATUS_ENUM setSrcBuffer(void**   pVAddrList,
+                                void**   pMVAddrList,
+                                uint32_t *pSizeList,
+                                uint32_t planeNumber);
+
+    // for ION file descriptor
+    DP_STATUS_ENUM setSrcBuffer(int32_t  fileDesc,
+                                uint32_t *sizeList,
+                                uint32_t planeNumber);
+
+    DP_STATUS_ENUM setSrcConfig(int32_t           width,
+                                int32_t           height,
+                                DpColorFormat     format,
+                                DpInterlaceFormat field = eInterlace_None,
+                                DpRect            *pROI = 0);
+
+    DP_STATUS_ENUM setSrcConfig(int32_t           width,
+                                int32_t           height,
+                                int32_t           yPitch,
+                                int32_t           uvPitch,
+                                DpColorFormat     format,
+                                DP_PROFILE_ENUM   profile = DP_PROFILE_BT601,
+                                DpInterlaceFormat field   = eInterlace_None,
+                                DpRect            *pROI   = 0,
+                                DpSecure          secure  = DP_SECURE_NONE,
+                                bool              doFlush = true);
+
+    DP_STATUS_ENUM setDstBuffer(void     *pVABase,
+                                uint32_t size);
+
+    DP_STATUS_ENUM setDstBuffer(void     **pVABaseList,
+                                uint32_t *pSizeList,
+                                uint32_t planeNumber);
+
+    // VA + MVA address interface
+    DP_STATUS_ENUM setDstBuffer(void**   pVABaseList,
+                                void**   pMVABaseList,
+                                uint32_t *pSizeList,
+                                uint32_t planeNumber);
+
+    // for ION file descriptor
+    DP_STATUS_ENUM setDstBuffer(int32_t  fileDesc,
+                                uint32_t *pSizeList,
+                                uint32_t planeNumber);
+
+    DP_STATUS_ENUM setDstConfig(int32_t           width,
+                                int32_t           height,
+                                DpColorFormat     format,
+                                DpInterlaceFormat field = eInterlace_None,
+                                DpRect            *pROI = 0);
+
+    DP_STATUS_ENUM setDstConfig(int32_t           width,
+                                int32_t           height,
+                                int32_t           yPitch,
+                                int32_t           uvPitch,
+                                DpColorFormat     format,
+                                DP_PROFILE_ENUM   profile = DP_PROFILE_BT601,
+                                DpInterlaceFormat field   = eInterlace_None,
+                                DpRect            *pROI   = 0,
+                                DpSecure          secure  = DP_SECURE_NONE,
+                                bool              doFlush = true);
+
+    DP_STATUS_ENUM setRotate(int32_t rotation)
+    {
+        if ((m_rotation != rotation) ||
+            (mRotate    != rotation))
+        {
+            m_rotation = rotation;
+            mRotate = rotation;
+            m_frameChange = true;
+        }
+
+        return DP_STATUS_RETURN_SUCCESS;
+    }
+
+    //Compatible to 89
+    DP_STATUS_ENUM setFlip(int flip)
+    {
+        if (mFlip != flip)
+        {
+            mFlip = flip;
+            m_flipStatus = ((flip!= 0)? true: false);
+            m_frameChange = true;
+        }
+
+        return DP_STATUS_RETURN_SUCCESS;
+    }
+
+    DP_STATUS_ENUM setOrientation(uint32_t transform);
+
+    DP_STATUS_ENUM setTdshp(int gain)
+    {
+        if (mTdshp != gain)
+        {
+            mTdshp        = gain;
+            m_frameChange = true;
+        }
+
+        return DP_STATUS_RETURN_SUCCESS;
+    }
+
+    uint32_t getPqID();
+
+    DP_STATUS_ENUM setPQParameter(const DpPqParam &pParam);
+
+    DP_STATUS_ENUM setDither(bool enDither)
+    {
+        if (m_ditherStatus != enDither)
+        {
+            m_ditherStatus = enDither;
+            m_frameChange  = true;
+        }
+
+        return DP_STATUS_RETURN_SUCCESS;
+    }
+
+    DP_STATUS_ENUM setAdaptiveLuma(bool enADL)
+    {
+        m_adaptiveLuma = enADL;
+
+        return DP_STATUS_RETURN_SUCCESS;
+    }
+
+    DP_STATUS_ENUM setUser(uint32_t eID = 0);
+
+
+    DP_STATUS_ENUM invalidate();
+
+    DP_STATUS_ENUM pq_process();
+
+    // for dump register
+    void enableDumpReg(unsigned int flags){mDumpRegFlags = flags;}
+
+private:
+    DpStream          *m_pStream;
+    DpChannel         *m_pChannel;
+    int32_t           m_channelID;
+    DpBasicBufferPool *m_pSrcPool;
+    DpBasicBufferPool *m_pDstPool;
+    int32_t           m_srcBuffer;
+    int32_t           m_srcWidth;
+    int32_t           m_srcHeight;
+    int32_t           m_srcYPitch;
+    int32_t           m_srcUVPitch;
+    DpColorFormat     m_srcFormat;
+    DP_PROFILE_ENUM   m_srcProfile;
+    DpSecure          m_srcSecure;
+    bool              m_srcFlush;
+    int32_t           m_dstBuffer;
+    int32_t           m_dstWidth;
+    int32_t           m_dstHeight;
+    int32_t           m_dstYPitch;
+    int32_t           m_dstUVPitch;
+    DpColorFormat     m_dstFormat;
+    DP_PROFILE_ENUM   m_dstProfile;
+    DpSecure          m_dstSecure;
+    bool              m_dstFlush;
+    DpStream          *m_pPqStream;
+    DpChannel         *m_pPqChannel;
+    DpAutoBufferPool  *m_pPqPool;    
+    int32_t           m_pqBuffer;
+    int32_t           m_cropXStart;
+    int32_t           m_cropYStart;
+    int32_t           m_cropWidth;
+    int32_t           m_cropHeight;
+    int32_t           m_cropSubPixelX;
+    int32_t           m_cropSubPixelY;
+    int32_t           m_targetXStart;
+    int32_t           m_targetYStart;
+    int32_t           m_rotation;
+    bool              m_frameChange;
+    bool              m_flipStatus;
+    bool              m_ditherStatus;
+    bool              m_adaptiveLuma;
+    uint32_t          m_userID;
+    DpPqConfig        m_PqConfig;
+    uint32_t          m_PqID;    
+    uint32_t          m_engFlag;
+    //Compatible to 89
+    int               mRotate;
+    int               mFlip;
+    int               mTdshp;
+
+    DpStream          *mStream;
+    DpChannel         *mChannel;
+    DpBufferPool      *mSrcPool;
+    DpBufferPool      *mDstPool;
+    DpPortOption      *mSrcPort;
+    DpPortOption      *mDstPort;
+    int               mSrcBufferId;
+    int               mDstBufferId;
+    unsigned int      mDumpRegFlags;
+};
+
+#endif  // __DP_BLIT_STREAM_H__
diff --git a/include/media/stagefright/dpframework/DpDataType.h b/include/media/stagefright/dpframework/DpDataType.h
new file mode 100644
index 000000000..d858e9727
--- /dev/null
+++ b/include/media/stagefright/dpframework/DpDataType.h
@@ -0,0 +1,450 @@
+#ifndef __DP_DATA_TYPE_H__
+#define __DP_DATA_TYPE_H__
+
+#ifndef __KERNEL__
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <math.h>
+#endif
+
+#ifndef MAX
+    #define MAX(x, y)   ((x) >= (y))? (x): (y)
+#endif // MAX
+
+#ifndef MIN
+    #define MIN(x, y)   ((x) <= (y))? (x): (y)
+#endif  // MIN
+
+#ifndef __KERNEL__
+class DpStream;
+class DpChannel;
+
+class DpBasicBufferPool;
+class DpAutoBufferPool;
+class DpCommand;
+class DpBufferPool;
+#endif
+
+typedef unsigned long long DpJobID;
+typedef int DpEngineType;
+
+typedef enum DP_STATUS_ENUM
+{
+    DP_STATUS_ABORTED_BY_USER   =  4,
+    DP_STATUS_ALL_TEST_DONE     =  3,
+    DP_STATUS_ALL_TPIPE_DONE    =  2,
+    DP_STATUS_BUFFER_DONE       =  1,
+    DP_STATUS_RETURN_SUCCESS    =  0,
+    DP_STATUS_INVALID_PARAX     = -1,
+    DP_STATUS_INVALID_PORT      = -2,
+    DP_STATUS_INVALID_PATH      = -3,
+    DP_STATUS_INVALID_FILE      = -4,
+    DP_STATUS_INVALID_CHANNEL   = -5,
+    DP_STATUS_INVALID_BUFFER    = -6,
+    DP_STATUS_INVALID_STATE     = -7,
+    DP_STATUS_INVALID_ENGINE    = -8,
+    DP_STATUS_INVALID_FORMAT    = -9,
+    DP_STATUS_INVALID_X_INPUT   = -10,
+    DP_STATUS_INVALID_Y_INPUT   = -11,
+    DP_STATUS_INVALID_X_OUTPUT  = -12,
+    DP_STATUS_INVALID_Y_OUTPUT  = -13,
+    DP_STATUS_INVALID_X_ALIGN   = -14,
+    DP_STATUS_INVALID_Y_ALIGN   = -15,
+    DP_STATUS_INVALID_WIDTH     = -16,
+    DP_STATUS_INVALID_HEIGHT    = -17,
+    DP_STATUS_INVALID_CROP      = -18,
+    DP_STATUS_INVALID_ANGLE     = -19,
+    DP_STATUS_INVALID_EVENT     = -20,
+    DP_STATUS_INVALID_OPCODE    = -21,
+    DP_STATUS_CAN_NOT_MERGE     = -22,
+    DP_STATUS_OUT_OF_MEMORY     = -23,
+    DP_STATUS_BUFFER_FULL       = -24,
+    DP_STATUS_BUFFER_EMPTY      = -25,
+    DP_STATUS_OPERATION_FAILED  = -26,
+    DP_STATUS_OVER_MAX_BRANCH   = -27,
+    DP_STATUS_OVER_MAX_ENGINE   = -28,
+    DP_STATUS_OVER_MAX_BACKUP   = -29,
+    DP_STATUS_SCHEDULE_ERROR    = -30,
+    DP_STATUS_OVER_MAX_WIDTH    = -31,
+    DP_STATUS_OVER_MAX_HEIGHT   = -32,
+    DP_STATUS_LEFT_EDGE_ERROR   = -33,
+    DP_STATUS_RIGHT_EDGE_ERROR  = -34,
+    DP_STATUS_TOP_EDGE_ERROR    = -35,
+    DP_STATUS_BOTTOM_EDGE_ERROR = -36,
+    DP_STATUS_X_LESS_THAN_LAST  = -37,
+    DP_STATUS_Y_LESS_THAN_LAST  = -38,
+    DP_STATUS_UNWANTED_X_CAL    = -39,
+    DP_STATUS_LOSS_OVER_WIDTH   = -40,
+    DP_STATUS_LOSS_OVER_HEIGHT  = -41,
+    DP_STATUS_X_ALIGN_ERROR     = -42,
+    DP_STATUS_Y_ALIGN_ERROR     = -43,
+    DP_STATUS_X_OUT_OVERLAP     = -44,
+    DP_STATUS_Y_OUT_OVERLAP     = -45,
+    DP_STATUS_BACK_LE_FORWARD   = -46,
+    DP_STATUS_UNKNOWN_ERROR     = -47,
+} DP_STATUS_ENUM;
+
+
+typedef enum DP_MEMORY_ENUM
+{
+    DP_MEMORY_VA,
+    DP_MEMORY_ION,
+    DP_MEMORY_PHY,
+    DP_MEMORY_MVA
+} DP_MEMORY_ENUM;
+
+typedef struct DpJPEGEnc_Config_st // for JPEG port only
+{
+    int32_t     fileDesc;
+    uint32_t    size;
+    uint32_t    fQuality;
+    uint32_t    soi_en;
+    void        *memSWAddr[3];
+} DpJPEGEnc_Config;
+
+typedef struct DpVEnc_Config // for VENC port only
+{
+    /* Venc Modify + */
+    unsigned long rVencDrvHandle;
+    /* Venc Modify - */
+    uint32_t    memYUVMVAAddr[3];
+    uint32_t    memYUVMVASize[3];
+    void        *memYUVSWAddr[3];
+    void        *memOutputSWAddr[3];
+
+    uint32_t*   pNumPABuffer;
+    uint32_t*   pPABuffer;
+    uint64_t*   pConfigFrameCount;
+    uint64_t*   pDequeueFrameCount;
+    DpCommand*  pVEncCommander;
+} DpVEnc_Config;
+
+
+#ifndef __KERNEL__
+class DpRect
+{
+public:
+
+    enum
+    {
+        eINVALID_VALUE = -1,
+        eINITIAL_VALUE = 0   //TBD, why to set as "0"?
+    };
+
+    inline DpRect(void)
+        : x(eINITIAL_VALUE), sub_x(eINITIAL_VALUE),
+          y(eINITIAL_VALUE), sub_y(eINITIAL_VALUE),
+          w(eINITIAL_VALUE), h(eINITIAL_VALUE)
+    {}
+
+    inline DpRect(int32_t in_x, int32_t in_y, int32_t in_w, int32_t in_h,
+                  int32_t in_sub_x = 0, int32_t in_sub_y = 0)
+        : x(in_x),
+          sub_x(in_sub_x),
+          y(in_y),
+          sub_y(in_sub_y),
+          w(in_w),
+          h(in_h)
+    {}
+
+    inline DpRect(const DpRect& rt)
+        : x(rt.x),
+          sub_x(rt.sub_x),
+          y(rt.y),
+          sub_y(rt.sub_y),
+          w(rt.w),
+          h(rt.h)
+    {}
+
+    ~DpRect(void) {}
+
+    inline DpRect& operator=  (const DpRect rval)
+    {
+        x = rval.x;
+        sub_x = rval.sub_x;
+        y = rval.y;
+        sub_y = rval.sub_y;
+        w = rval.w;
+        h = rval.h;
+        return *this;
+    }
+
+    int32_t x;
+    int32_t sub_x;
+    int32_t y;
+    int32_t sub_y;
+    int32_t w;
+    int32_t h;
+};
+#endif
+
+typedef enum DP_PROFILE_ENUM
+{
+    DP_PROFILE_BT601, //Limited range
+    DP_PROFILE_BT709,
+    DP_PROFILE_JPEG,
+    DP_PROFILE_FULL_BT601 = DP_PROFILE_JPEG
+} DP_PROFILE_ENUM;
+
+
+typedef enum DP_STREAM_ID_ENUM
+{
+    DP_BLITSTREAM       = 0x10000000,
+    DP_FRAGSTREAM       = 0x20000000,
+    DP_ISPSTREAM        = 0x30000000,
+    DP_ASYNCBLITSTREAM  = 0x40000000,
+    DP_UNKNOWN_STREAM   = 0xF0000000,
+} DP_STREAM_ID_ENUM;
+
+typedef enum DP_MEDIA_TYPE_ENUM
+{
+    MEDIA_UNKNOWN,
+    MEDIA_VIDEO,
+    MEDIA_PICTURE,
+    MEDIA_ISP_PREVIEW
+} DP_MEDIA_TYPE_ENUM;
+
+typedef struct
+{
+    uint32_t id;
+    uint32_t timeStamp;
+    uint32_t reserved[28];   // padding and reserved
+} DpVideoParam;
+
+typedef struct
+{
+    bool withHist;
+    uint32_t info[20];
+    uint32_t reserved[9];  // padding and reserved
+} DpImageParam;
+
+struct DpPqParam {
+    bool enable;
+    DP_MEDIA_TYPE_ENUM scenario;
+
+    union {
+        DpVideoParam video;
+        DpImageParam image;
+    } u;
+};
+
+struct DpPqConfig {
+    uint32_t enSharp;
+    uint32_t enDC;
+    uint32_t enColor;
+};
+
+
+//FMT GROUP , 0-RGB , 1-YUV , 2-Bayer raw , 3-compressed format
+#define DP_COLORFMT_PACK(VIDEO, PLANE, COPLANE, HFACTOR, VFACTOR, BITS, GROUP ,SWAP_ENABLE, UNIQUEID)  \
+    ((VIDEO         << 27) |                                                             \
+     (PLANE         << 24) |                                                             \
+     (COPLANE       << 22) |                                                             \
+     (HFACTOR       << 20) |                                                             \
+     (VFACTOR       << 18) |                                                             \
+     (BITS          << 8)  |                                                             \
+     (GROUP         << 6)  |                                                             \
+     (SWAP_ENABLE   << 5)  |                                                             \
+     (UNIQUEID      << 0))
+
+#define DP_COLOR_GET_UFP_ENABLE(color)          ((0x20000000 & color) >> 29)
+#define DP_COLOR_GET_INTERLACED_MODE(color)     ((0x10000000 & color) >> 28)
+#define DP_COLOR_GET_BLOCK_MODE(color)          ((0x08000000 & color) >> 27)
+#define DP_COLOR_GET_PLANE_COUNT(color)         ((0x07000000 & color) >> 24)
+#define DP_COLOR_IS_UV_COPLANE(color)           ((0x00C00000 & color) >> 22)
+#define DP_COLOR_GET_H_SUBSAMPLE(color)         ((0x00300000 & color) >> 20)
+#define DP_COLOR_GET_V_SUBSAMPLE(color)         ((0x000C0000 & color) >> 18)
+#define DP_COLOR_BITS_PER_PIXEL(color)          ((0x0003FF00 & color) >>  8)
+#define DP_COLOR_GET_COLOR_GROUP(color)         ((0x000000C0 & color) >>  6)
+#define DP_COLOR_GET_SWAP_ENABLE(color)         ((0x00000020 & color) >>  5)
+#define DP_COLOR_GET_UNIQUE_ID(color)           ((0x0000001F & color) >>  0)
+#define DP_COLOR_GET_HW_FORMAT(color)           ((0x0000001F & color) >>  0)
+
+typedef enum DP_COLOR_ENUM
+{
+    DP_COLOR_UNKNOWN        = 0,
+    DP_COLOR_FULLG8         = DP_COLORFMT_PACK(0,   1,  0, 0, 0,  8, 3,  0, 20),
+    DP_COLOR_FULLG10        = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 10, 3,  0, 21),
+    DP_COLOR_FULLG12        = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 12, 3,  0, 22),
+    DP_COLOR_FULLG14        = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 14, 3,  0, 26),
+    DP_COLOR_UFO10          = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 10, 3,  0, 27),
+
+    DP_COLOR_BAYER8         = DP_COLORFMT_PACK(0,   1,  0, 0, 0,  8, 2,  0, 20),
+    DP_COLOR_BAYER10        = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 10, 2,  0, 21),
+    DP_COLOR_BAYER12        = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 12, 2,  0, 22),
+
+    // Unified format
+    DP_COLOR_GREY           = DP_COLORFMT_PACK(0,   1,  0, 0, 0,  8, 1,  0, 7),
+
+    DP_COLOR_RGB565         = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 16, 0,  0, 0),
+    DP_COLOR_BGR565         = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 16, 0,  1, 0),
+    DP_COLOR_RGB888         = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 24, 0,  1, 1),
+    DP_COLOR_BGR888         = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 24, 0,  0, 1),
+    DP_COLOR_RGBA8888       = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 32, 0,  1, 2),
+    DP_COLOR_BGRA8888       = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 32, 0,  0, 2),
+    DP_COLOR_ARGB8888       = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 32, 0,  1, 3),
+    DP_COLOR_ABGR8888       = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 32, 0,  0, 3),
+
+    DP_COLOR_UYVY           = DP_COLORFMT_PACK(0,   1,  0, 1, 0, 16, 1,  0, 4),
+    DP_COLOR_VYUY           = DP_COLORFMT_PACK(0,   1,  0, 1, 0, 16, 1,  1, 4),
+    DP_COLOR_YUYV           = DP_COLORFMT_PACK(0,   1,  0, 1, 0, 16, 1,  0, 5),
+    DP_COLOR_YVYU           = DP_COLORFMT_PACK(0,   1,  0, 1, 0, 16, 1,  1, 5),
+
+    DP_COLOR_I420           = DP_COLORFMT_PACK(0,   3,  0, 1, 1,  8, 1,  0, 8),
+    DP_COLOR_YV12           = DP_COLORFMT_PACK(0,   3,  0, 1, 1,  8, 1,  1, 8),
+    DP_COLOR_I422           = DP_COLORFMT_PACK(0,   3,  0, 1, 0,  8, 1,  0, 9),
+    DP_COLOR_YV16           = DP_COLORFMT_PACK(0,   3,  0, 1, 0,  8, 1,  1, 9),
+    DP_COLOR_I444           = DP_COLORFMT_PACK(0,   3,  0, 0, 0,  8, 1,  0, 10),
+    DP_COLOR_YV24           = DP_COLORFMT_PACK(0,   3,  0, 0, 0,  8, 1,  1, 10),
+
+    DP_COLOR_NV12           = DP_COLORFMT_PACK(0,   2,  1, 1, 1,  8, 1,  0, 12),
+    DP_COLOR_NV21           = DP_COLORFMT_PACK(0,   2,  1, 1, 1,  8, 1,  1, 12),
+    DP_COLOR_NV16           = DP_COLORFMT_PACK(0,   2,  1, 1, 0,  8, 1,  0, 13),
+    DP_COLOR_NV61           = DP_COLORFMT_PACK(0,   2,  1, 1, 0,  8, 1,  1, 13),
+    DP_COLOR_NV24           = DP_COLORFMT_PACK(0,   2,  1, 0, 0,  8, 1,  0, 14),
+    DP_COLOR_NV42           = DP_COLORFMT_PACK(0,   2,  1, 0, 0,  8, 1,  1, 14),
+
+    // Mediatek proprietary format
+    DP_COLOR_420_BLKP_UFO   = DP_COLORFMT_PACK(5,   2,  1, 1, 1, 256, 1, 0, 12),//Frame mode + Block mode
+    DP_COLOR_420_BLKP       = DP_COLORFMT_PACK(1,   2,  1, 1, 1, 256, 1, 0, 12),//Frame mode + Block mode
+    DP_COLOR_420_BLKI       = DP_COLORFMT_PACK(3,   2,  1, 1, 1, 256, 1, 0, 12),//Field mode + Block mode
+    DP_COLOR_422_BLKP       = DP_COLORFMT_PACK(1,   1,  0, 1, 0, 512, 1, 0, 4), //Frame mode
+
+    DP_COLOR_PARGB8888      = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 32,  0, 0, 26),
+    DP_COLOR_XARGB8888      = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 32,  0, 0, 27),
+    DP_COLOR_PABGR8888      = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 32,  0, 0, 28),
+    DP_COLOR_XABGR8888      = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 32,  0, 0, 29),
+
+    DP_COLOR_IYU2           = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 24,  1, 0, 25),
+    DP_COLOR_YUV444         = DP_COLORFMT_PACK(0,   1,  0, 0, 0, 24,  1, 0, 30),
+//    DP_COLOR_YUV422I        = DP_COLORFMT_PACK(1,  0, 1, 0, 16, 1, 41),//Dup to DP_COLOR_YUYV
+//    DP_COLOR_Y800           = DP_COLORFMT_PACK(1,  0, 1, 0, 8, 1, 42),//Dup to DP_COLOR_GREY
+//    DP_COLOR_COMPACT_RAW1   = DP_COLORFMT_PACK(1,  0, 1, 0, 10, 2, 43),//Dup to Bayer10
+//    DP_COLOR_420_3P_YVU     = DP_COLORFMT_PACK(3,  0, 1, 1,  8, 1, 44),//Dup to DP_COLOR_YV12
+} DP_COLOR_ENUM;
+
+// Legacy for 6589 compatible
+typedef DP_COLOR_ENUM DpColorFormat;
+
+#define eYUV_420_3P             DP_COLOR_I420
+#define eYUV_420_2P_YUYV        DP_COLOR_YUYV
+#define eYUV_420_2P_UYVY        DP_COLOR_UYVY
+#define eYUV_420_2P_YVYU        DP_COLOR_YVYU
+#define eYUV_420_2P_VYUY        DP_COLOR_VYUY
+#define eYUV_420_2P_ISP_BLK     DP_COLOR_420_BLKP
+#define eYUV_420_2P_VDO_BLK     DP_COLOR_420_BLKI
+#define eYUV_422_3P             DP_COLOR_I422
+#define eYUV_422_2P             DP_COLOR_NV16
+#define eYUV_422_I              DP_COLOR_YUYV
+#define eYUV_422_I_BLK          DP_COLOR_422_BLKP
+#define eYUV_444_3P             DP_COLOR_I444
+#define eYUV_444_2P             DP_COLOR_NV24
+#define eYUV_444_1P             DP_COLOR_YUV444
+#define eBAYER8                 DP_COLOR_BAYER8
+#define eBAYER10                DP_COLOR_BAYER10
+#define eBAYER12                DP_COLOR_BAYER12
+#define eRGB565                 DP_COLOR_RGB565
+#define eBGR565                 DP_COLOR_BGR565
+#define eRGB888                 DP_COLOR_RGB888
+#define eBGR888                 DP_COLOR_BGR888
+#define eARGB8888               DP_COLOR_ARGB8888
+#define eABGR8888               DP_COLOR_ABGR8888
+#define DP_COLOR_XRGB8888       DP_COLOR_ARGB8888
+#define DP_COLOR_XBGR8888       DP_COLOR_ABGR8888
+#define eRGBA8888               DP_COLOR_RGBA8888
+#define eBGRA8888               DP_COLOR_BGRA8888
+#define eXRGB8888               DP_COLOR_XRGB8888
+#define eXBGR8888               DP_COLOR_XBGR8888
+#define DP_COLOR_RGBX8888       DP_COLOR_RGBA8888
+#define DP_COLOR_BGRX8888       DP_COLOR_BGRA8888
+#define eRGBX8888               DP_COLOR_RGBX8888
+#define eBGRX8888               DP_COLOR_BGRX8888
+#define ePARGB8888              DP_COLOR_PARGB8888
+#define eXARGB8888              DP_COLOR_XARGB8888
+#define ePABGR8888              DP_COLOR_PABGR8888
+#define eXABGR8888              DP_COLOR_XABGR8888
+#define eGREY                   DP_COLOR_GREY
+#define eI420                   DP_COLOR_I420
+#define eYV12                   DP_COLOR_YV12
+#define eIYU2                   DP_COLOR_IYU2
+
+
+#define eYV21                   DP_COLOR_I420
+#define eNV12_BLK               DP_COLOR_420_BLKP
+#define eNV12_BLK_FCM           DP_COLOR_420_BLKI
+#define eYUV_420_3P_YVU         DP_COLOR_YV12
+
+#define eNV12_BP                DP_COLOR_420_BLKP
+#define eNV12_BI                DP_COLOR_420_BLKI
+#define eNV12                   DP_COLOR_NV12
+#define eNV21                   DP_COLOR_NV21
+#define eI422                   DP_COLOR_I422
+#define eYV16                   DP_COLOR_YV16
+#define eNV16                   DP_COLOR_NV16
+#define eNV61                   DP_COLOR_NV61
+#define eUYVY                   DP_COLOR_UYVY
+#define eVYUY                   DP_COLOR_VYUY
+#define eYUYV                   DP_COLOR_YUYV
+#define eYVYU                   DP_COLOR_YVYU
+#define eUYVY_BP                DP_COLOR_422_BLKP
+#define eI444                   DP_COLOR_I444
+#define eNV24                   DP_COLOR_NV24
+#define eNV42                   DP_COLOR_NV42
+#define DP_COLOR_YUY2           DP_COLOR_YUYV
+#define eYUY2                   DP_COLOR_YUY2
+#define eY800                   DP_COLOR_GREY
+//#define eIYU2
+#define eMTKYUV                 DP_COLOR_422_BLKP
+
+#define eCompactRaw1            DP_COLOR_BAYER10
+
+
+enum DpInterlaceFormat
+{
+    eInterlace_None,
+    eTop_Field,
+    eBottom_Field
+};
+
+enum DpSecure
+{
+    DP_SECURE_NONE  = 0,
+    DP_SECURE       = 1,
+    DP_SECURE_SHIFT = 8
+};
+
+#define MAX_NUM_READBACK_REGS (20)
+
+#define VENC_ENABLE_FLAG    (0x08967)
+
+#ifndef __KERNEL__
+struct DpPortOption
+{
+    int width;
+    int height;
+    DpRect ROI;
+    DpColorFormat format;
+    DpInterlaceFormat interlace;
+
+    enum DpPort
+    {
+        eLCD0_PORT,
+        eLCD1_PORT,
+        eHDMI_PORT,
+        eTVOUT_PORT,
+        eOVERLAY_PORT,
+        eVIRTUAL_PORT,
+        eMEMORY_PORT
+    };
+
+    DpPort port;
+
+    int overlayID;              // setting if choose port = eOVERLAY
+    int virtualID;              // setting if choose port = eVIRTUAL_PORT
+    DpBufferPool *buffer;       // setting if choose port = eMEMORY
+};
+#endif  // __KERNEL__
+
+#endif  // __DP_DATA_TYPE_H__
diff --git a/media/libmediaplayerservice/Android.mk b/media/libmediaplayerservice/Android.mk
index 6575625e9..08d53260b 100644
--- a/media/libmediaplayerservice/Android.mk
+++ b/media/libmediaplayerservice/Android.mk
@@ -58,6 +58,11 @@ LOCAL_C_INCLUDES :=                                                 \
     $(TOP)/external/tremolo/Tremolo                                 \
     $(TOP)/frameworks/av/media/libavextensions                      \
 
+# Mediatek
+ifeq ($(strip $(BOARD_HAS_MTK_HARDWARE)),true)
+LOCAL_SHARED_LIBRARIES += libmtkplayer
+endif
+
 LOCAL_CFLAGS += -Werror -Wno-error=deprecated-declarations -Wall #-DLOG_NDEBUG=0
 LOCAL_CLANG := true
 
diff --git a/media/libmediaplayerservice/FMAudioPlayer.h b/media/libmediaplayerservice/FMAudioPlayer.h
new file mode 100644
index 000000000..0f239d452
--- /dev/null
+++ b/media/libmediaplayerservice/FMAudioPlayer.h
@@ -0,0 +1,144 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef ANDROID_FM_AUDIOPLAYER_H
+#define ANDROID_FM_AUDIOPLAYER_H
+
+
+#include <utils/threads.h>
+
+#include <media/MediaPlayerInterface.h>
+#include <media/AudioTrack.h>
+#include <media/AudioRecord.h>
+
+namespace android
+{
+
+class FMAudioPlayer : public MediaPlayerInterface
+{
+public:
+    FMAudioPlayer();
+    ~FMAudioPlayer();
+
+    virtual void        onFirstRef();
+    virtual status_t    initCheck();
+    //virtual status_t    setDataSource(const char *path, const KeyedVector<String8, String8> *headers);
+    virtual status_t    setDataSource(const sp<IMediaHTTPService> &httpService, const char *url, const KeyedVector<String8, String8> *headers);
+    virtual status_t    setDataSource(int fd, int64_t offset, int64_t length);
+    virtual status_t    setVideoSurface(const sp<Surface>& /*surface*/)
+    {
+        return UNKNOWN_ERROR;
+    }
+    virtual status_t    setVideoSurfaceTexture(
+        const sp<IGraphicBufferProducer>& /*bufferProducer*/)
+    {
+        return UNKNOWN_ERROR;
+    }
+    virtual status_t    prepare();
+    virtual status_t    prepareAsync();
+    virtual status_t    start();
+    virtual status_t    stop();
+    virtual status_t    seekTo(int msec);
+    virtual status_t    pause();
+    virtual bool        isPlaying();
+    virtual status_t    getCurrentPosition(int *msec);
+    virtual status_t    getDuration(int *msec);
+    virtual status_t    release();
+    virtual status_t    reset();
+    virtual status_t    setLooping(int loop);
+#ifndef FAKE_FM
+    virtual status_t    setRender(bool enable);
+#endif
+    virtual player_type playerType()
+    {
+        return FM_AUDIO_PLAYER;
+    }
+    virtual status_t    invoke(const Parcel &/*request*/, Parcel */*reply*/)
+    {
+        return INVALID_OPERATION;
+    }
+    virtual status_t    setParameter(int /*key*/, const Parcel &/*request*/)
+    {
+        return INVALID_OPERATION;
+    }
+    virtual status_t    getParameter(int /*key*/, Parcel */*reply*/)
+    {
+        return INVALID_OPERATION;
+    }
+
+private:
+    status_t    setdatasource(const char *path, int fd, int64_t offset, int64_t length);
+    status_t    reset_nosync();
+    status_t    createOutputTrack();
+    static int  renderThread(void *);
+    int         render();
+    bool        createAudioRecord();
+    bool        deleteAudioRecord();
+
+#ifndef FAKE_FM
+    void        setHwCallback(bool enable);
+#endif
+
+    sp<AudioRecord>      mAudioRecord;
+    Mutex               mMutex;
+    Condition           mCondition;
+    FILE               *mFile;
+    int64_t             mOffset;
+    int64_t             mLength;
+    char               *mAudioBuffer;
+    char               *mDummyBuffer;
+    int                 mPlayTime;
+    int                 mDuration;
+    uint32_t            mFmAudioSamplingRate;
+
+    status_t            mState;
+    int                 mStreamType;
+    bool                mAndroidLoop;
+    volatile bool       mExit;
+    bool                mPaused;
+		
+    bool		mSetRender;
+    volatile bool       mRender;
+    pid_t               mRenderTid;
+    bool 		flagRecordError;
+
+    int mMutePause;
+};
+
+}; // namespace android
+
+#endif
+
+
diff --git a/media/libmediaplayerservice/MediaPlayerFactory.cpp b/media/libmediaplayerservice/MediaPlayerFactory.cpp
index f0afc5a0f..e378f3ca2 100644
--- a/media/libmediaplayerservice/MediaPlayerFactory.cpp
+++ b/media/libmediaplayerservice/MediaPlayerFactory.cpp
@@ -34,6 +34,10 @@
 #include "nuplayer/NuPlayerDriver.h"
 #include <mediaplayerservice/AVMediaServiceExtensions.h>
 
+#ifdef MTK_HARDWARE
+#include "FMAudioPlayer.h"
+#endif
+
 namespace android {
 
 Mutex MediaPlayerFactory::sLock;
@@ -241,6 +245,24 @@ class TestPlayerFactory : public MediaPlayerFactory::IFactory {
     }
 };
 
+#ifdef MTK_HARDWARE
+class FMPlayerFactory : public MediaPlayerFactory::IFactory {
+  public:
+    virtual float scoreFactory(const sp<IMediaPlayer>& /*client*/,
+                               const char* url,
+                               float /*curScore*/) {
+        if(strncmp(url, "MEDIATEK://MEDIAPLAYER_PLAYERTYPE_FM", 36) == 0)
+           return 1.0;
+        return 0.0;
+    }
+
+    virtual sp<MediaPlayerBase> createPlayer(pid_t /* pid */) {
+        ALOGV("Create FM Player");
+        return new FMAudioPlayer();
+    }
+};
+#endif
+
 void MediaPlayerFactory::registerBuiltinFactories() {
 
     MediaPlayerFactory::IFactory* pCustomFactory = NULL;
@@ -256,6 +278,9 @@ void MediaPlayerFactory::registerBuiltinFactories() {
         ALOGV("Registering DASH_PLAYER");
         registerFactory_l(pCustomFactory, DASH_PLAYER);
     }
+#ifdef MTK_HARDWARE
+    registerFactory_l(new FMPlayerFactory(), FM_AUDIO_PLAYER);
+#endif
 
     sInitComplete = true;
 }
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 442dba1a9..1e217cab0 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -1613,6 +1613,14 @@ status_t StagefrightRecorder::setupVideoEncoder(
             break;
     }
 
+    // force hw video encoder for camera
+    if (mVideoSource == VIDEO_SOURCE_CAMERA) {
+        AString mime;
+        CHECK(format->findString("mime", &mime));
+        mime.append("_cam");
+        format->setString("mime", mime);
+    }
+
     if (cameraSource != NULL) {
         sp<MetaData> meta = cameraSource->getFormat();
 
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 581bfba31..4f5ad7167 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -63,6 +63,16 @@
 
 #include <stagefright/AVExtensions.h>
 
+#ifdef MTK_HARDWARE
+#include <media/stagefright/dpframework/DpBlitStream.h>
+
+#define HAL_PIXEL_FORMAT_NV12_BLK 0x7F000001
+#define HAL_PIXEL_FORMAT_I420 (0x32315659 + 0x10)
+
+const OMX_COLOR_FORMATTYPE OMX_MTK_COLOR_FormatYV12 = (OMX_COLOR_FORMATTYPE)0x7F000200;
+const OMX_COLOR_FORMATTYPE OMX_COLOR_FormatVendorMTKYUV = (OMX_COLOR_FORMATTYPE)0x7F000001;
+#endif
+
 namespace android {
 
 // OMX errors are directly mapped into status_t range if
@@ -824,7 +834,13 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
                     def.nBufferCountActual, bufSize, allottedSize, def.nBufferSize, asString(type),
                     portIndex == kPortIndexInput ? "input" : "output");
 
+#ifdef MTK_HARDWARE
+            OMX_U32 memoryAlign = 32;
+            size_t totalSize = def.nBufferCountActual *
+                ((bufSize + (memoryAlign - 1))&(~(memoryAlign - 1)));
+#else
             size_t totalSize = def.nBufferCountActual * bufSize;
+#endif
             mDealer[portIndex] = new MemoryDealer(totalSize, "ACodec");
 
             for (OMX_U32 i = 0; i < def.nBufferCountActual && err == OK; ++i) {
@@ -925,6 +941,11 @@ status_t ACodec::setupNativeWindowSizeFormatAndUsage(
     setNativeWindowColorFormat(eNativeColorFormat);
 #endif
 
+#ifdef MTK_HARDWARE
+    OMX_COLOR_FORMATTYPE eHalColorFormat = def.format.video.eColorFormat;
+    setHalWindowColorFormat(eHalColorFormat);
+#endif
+
     ALOGV("gralloc usage: %#x(OMX) => %#x(ACodec)", omxUsage, usage);
     int32_t width = 0, height = 0;
     int32_t isAdaptivePlayback = 0;
@@ -946,6 +967,8 @@ status_t ACodec::setupNativeWindowSizeFormatAndUsage(
             height,
 #ifdef USE_SAMSUNG_COLORFORMAT
             eNativeColorFormat,
+#elif MTK_HARDWARE
+            eHalColorFormat,
 #else
             def.format.video.eColorFormat,
 #endif
@@ -1329,6 +1352,27 @@ void ACodec::setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat
 }
 #endif
 
+#ifdef MTK_HARDWARE
+void ACodec::setHalWindowColorFormat(OMX_COLOR_FORMATTYPE &eHalColorFormat) {
+    if (!strncmp("OMX.MTK.", mComponentName.c_str(), 8)) {
+        switch (eHalColorFormat) {
+            case OMX_COLOR_FormatYUV420Planar:
+                eHalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_I420;
+                break;
+            case OMX_MTK_COLOR_FormatYV12:
+                eHalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+                break;
+            case OMX_COLOR_FormatVendorMTKYUV:
+                eHalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_NV12_BLK;
+                break;
+            default:
+                eHalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_I420;
+                break;
+        }
+    }
+}
+#endif
+
 status_t ACodec::cancelBufferToNativeWindow(BufferInfo *info) {
     CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_US);
 
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 792c139ea..b8e5f2c9e 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -212,6 +212,17 @@ LOCAL_C_INCLUDES += \
 	$(TOP)/hardware/samsung/exynos4/include
 endif
 
+# Mediatek
+ifeq ($(strip $(BOARD_HAS_MTK_HARDWARE)),true)
+LOCAL_CFLAGS += -DMTK_HARDWARE
+
+LOCAL_C_INCLUDES += \
+	$(TOP)/hardware/mediatek/dpframework/inc
+
+LOCAL_SHARED_LIBRARIES += \
+	libdpframework
+endif
+
 LOCAL_MODULE:= libstagefright
 
 LOCAL_MODULE_TAGS := optional
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index f6b4741da..894e55d6c 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -43,6 +43,10 @@
 #define UNUSED_UNLESS_VERBOSE(x)
 #endif
 
+#ifdef MTK_HARDWARE
+#define OMX_MTK_COLOR_FormatYV12 0x7F000200
+#endif
+
 namespace android {
 
 static const int64_t CAMERA_SOURCE_TIMEOUT_NS = 3000000000LL;
@@ -108,7 +112,11 @@ static int32_t getColorFormat(const char* colorFormat) {
     }
 
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P)) {
+#ifdef	MTK_HARDWARE
+       return OMX_MTK_COLOR_FormatYV12;
+#else
        return OMX_COLOR_FormatYUV420Planar;
+#endif
     }
 
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV422SP)) {
@@ -151,6 +159,12 @@ static int32_t getColorFormat(const char* colorFormat) {
         return OMX_QCOM_COLOR_FormatYVU420SemiPlanar;
     }
 
+#ifdef MTK_HARDWARE
+    if (!strcmp(colorFormat, "yuv420i-yyuvyy-3plane")) {
+       return OMX_COLOR_FormatYUV420Planar;
+    }
+#endif
+
     ALOGE("Uknown color format (%s), please add it to "
          "CameraSource::getColorFormat", colorFormat);
 
diff --git a/media/libstagefright/MediaCodecSource.cpp b/media/libstagefright/MediaCodecSource.cpp
index 14a3c0d74..3fe82c292 100644
--- a/media/libstagefright/MediaCodecSource.cpp
+++ b/media/libstagefright/MediaCodecSource.cpp
@@ -411,6 +411,12 @@ status_t MediaCodecSource::initEncoder() {
             mCodecLooper, outputMIME.c_str(), true /* encoder */);
     }
 
+    // remove camera tag from mime
+    if (outputMIME.endsWith("_cam")) {
+        outputMIME.erase(outputMIME.size() - 4, 4);
+        mOutputFormat->setString("mime", outputMIME);
+    }
+
     if (mEncoder == NULL) {
         return NO_INIT;
     }
diff --git a/media/libstagefright/MediaSync.cpp b/media/libstagefright/MediaSync.cpp
index 3a45e2521..c5dcd3a53 100644
--- a/media/libstagefright/MediaSync.cpp
+++ b/media/libstagefright/MediaSync.cpp
@@ -346,7 +346,7 @@ void MediaSync::flush() {
         mFrameScheduler->restart();
     }
     while (!mBufferItems.empty()) {
-        BufferItem *bufferItem = &*mBufferItems.begin();
+        BufferQueue::BufferItem *bufferItem = &*mBufferItems.begin();
         returnBufferToInput_l(bufferItem->mGraphicBuffer, bufferItem->mFence);
         mBufferItems.erase(mBufferItems.begin());
     }
@@ -552,7 +552,7 @@ void MediaSync::onDrainVideo_l() {
 
     while (!mBufferItems.empty()) {
         int64_t nowUs = ALooper::GetNowUs();
-        BufferItem *bufferItem = &*mBufferItems.begin();
+        BufferQueue::BufferItem *bufferItem = &*mBufferItems.begin();
         int64_t itemMediaUs = bufferItem->mTimestamp / 1000;
         int64_t itemRealUs = getRealTime(itemMediaUs, nowUs);
 
@@ -625,7 +625,7 @@ void MediaSync::onFrameAvailableFromInput() {
     }
 
     // Acquire and detach the buffer from the input.
-    BufferItem bufferItem;
+    BufferQueue::BufferItem bufferItem;
     status_t status = mInput->acquireBuffer(&bufferItem, 0 /* presentWhen */);
     if (status != NO_ERROR) {
         ALOGE("acquiring buffer from input failed (%d)", status);
@@ -669,7 +669,7 @@ void MediaSync::onFrameAvailableFromInput() {
     }
 }
 
-void MediaSync::renderOneBufferItem_l(const BufferItem &bufferItem) {
+void MediaSync::renderOneBufferItem_l(const BufferQueue::BufferItem &bufferItem) {
     IGraphicBufferProducer::QueueBufferInput queueInput(
             bufferItem.mTimestamp,
             bufferItem.mIsAutoTimestamp,
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index de00ff282..fc24ca0d6 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -214,6 +214,17 @@ void OMXCodec::findMatchingCodecs(
         return;
     }
 
+    AString *tempMime = new AString(mime);
+    if (tempMime->endsWith("_cam")) {
+        // remove camera tag from mime
+        tempMime->erase(tempMime->size() - 4, 4);
+        mime = tempMime->c_str();
+    }
+    else {
+        // no camera recording, prefer software codecs
+        flags |= kPreferSoftwareCodecs;
+    }
+
     size_t index = 0;
     for (;;) {
         ssize_t matchIndex =
diff --git a/media/libstagefright/SurfaceMediaSource.cpp b/media/libstagefright/SurfaceMediaSource.cpp
index 147eb455d..2fd3dabcb 100644
--- a/media/libstagefright/SurfaceMediaSource.cpp
+++ b/media/libstagefright/SurfaceMediaSource.cpp
@@ -26,7 +26,6 @@
 #include <media/hardware/MetadataBufferType.h>
 
 #include <ui/GraphicBuffer.h>
-#include <gui/BufferItem.h>
 #include <gui/ISurfaceComposer.h>
 #include <gui/IGraphicBufferAlloc.h>
 #include <OMX_Component.h>
@@ -298,7 +297,7 @@ status_t SurfaceMediaSource::read(
     // TODO: mCurrentSlot can be made a bufferstate since there
     // can be more than one "current" slots.
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
     // If the recording has started and the queue is empty, then just
     // wait here till the frames come in from the client side
     while (mStarted) {
diff --git a/media/libstagefright/colorconversion/Android.mk b/media/libstagefright/colorconversion/Android.mk
index 4f7c48f74..3f65c42a5 100644
--- a/media/libstagefright/colorconversion/Android.mk
+++ b/media/libstagefright/colorconversion/Android.mk
@@ -9,6 +9,13 @@ LOCAL_C_INCLUDES := \
         $(TOP)/frameworks/native/include/media/openmax \
         $(TOP)/hardware/msm7k
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+LOCAL_CFLAGS += -DMTK_HARDWARE
+
+LOCAL_C_INCLUDES += \
+        $(TOP)/frameworks/av/include/media/stagefright/dpframework
+endif
+
 LOCAL_CFLAGS += -Werror
 LOCAL_CLANG := true
 
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index 597167f91..b43a3b93f 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -22,6 +22,14 @@
 #include <media/stagefright/ColorConverter.h>
 #include <media/stagefright/MediaErrors.h>
 
+#ifdef MTK_HARDWARE
+#include <DpBlitStream.h>
+
+const OMX_COLOR_FORMATTYPE OMX_MTK_COLOR_FormatYV12 = (OMX_COLOR_FORMATTYPE)0x7F000200;
+const OMX_COLOR_FORMATTYPE OMX_COLOR_FormatVendorMTKYUV = (OMX_COLOR_FORMATTYPE)0x7F000001;
+const OMX_COLOR_FORMATTYPE OMX_COLOR_FormatVendorMTKYUV_FCM = (OMX_COLOR_FORMATTYPE)0x7F000002;
+#endif
+
 namespace android {
 
 ColorConverter::ColorConverter(
@@ -47,6 +55,11 @@ bool ColorConverter::isValid() const {
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+#ifdef MTK_HARDWARE
+        case OMX_MTK_COLOR_FormatYV12:
+        case OMX_COLOR_FormatVendorMTKYUV:
+        case OMX_COLOR_FormatVendorMTKYUV_FCM:
+#endif
             return true;
 
         default:
@@ -103,7 +116,11 @@ status_t ColorConverter::convert(
 
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
+#ifdef MTK_HARDWARE
+            err = convertYUVToRGBHW(src, dst);
+#else
             err = convertYUV420Planar(src, dst);
+#endif
             break;
 
         case OMX_COLOR_FormatCbYCrY:
@@ -122,6 +139,14 @@ status_t ColorConverter::convert(
             err = convertTIYUV420PackedSemiPlanar(src, dst);
             break;
 
+#ifdef MTK_HARDWARE
+        case OMX_MTK_COLOR_FormatYV12:
+        case OMX_COLOR_FormatVendorMTKYUV:
+        case OMX_COLOR_FormatVendorMTKYUV_FCM:
+            err = convertYUVToRGBHW(src, dst);
+            break;
+#endif
+
         default:
         {
             CHECK(!"Should not be here. Unknown color conversion.");
@@ -521,4 +546,92 @@ uint8_t *ColorConverter::initClip() {
     return &mClip[-kClipMin];
 }
 
+#ifdef MTK_HARDWARE
+status_t ColorConverter::convertYUVToRGBHW(const BitmapParams &src, const BitmapParams &dst) {
+    DpBlitStream blitStream;
+    unsigned int srcWStride = src.mWidth;
+    unsigned int srcHStride = src.mHeight;
+
+    DpRect srcRoi;
+    srcRoi.x = src.mCropLeft;
+    srcRoi.y = src.mCropTop;
+    srcRoi.w = src.mCropRight - src.mCropLeft;
+    srcRoi.h = src.mCropBottom - src.mCropTop;
+
+    unsigned int dstWStride = dst.mWidth ;
+    unsigned int dstHStride = dst.mHeight ;
+    char name_yuv[100];
+    char retriever_yuv_propty[100];
+    char name_rgb[100];
+    char retriever_propty_rgb[100];
+
+    if (mSrcFormat == OMX_COLOR_FormatYUV420Planar) {
+        char* planar[3];
+        unsigned int length[3];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+	      length[1] = srcWStride*srcHStride/4;
+        planar[2] = planar[1] + length[1];
+        length[2] = length[1];
+
+        blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 3);
+        blitStream.setSrcConfig(srcWStride, srcHStride, eYUV_420_3P, eInterlace_None, &srcRoi);
+    }
+    else if (mSrcFormat == OMX_MTK_COLOR_FormatYV12) {
+        char* planar[3];
+        unsigned int length[3];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = srcWStride*srcHStride/4;
+        planar[2] = planar[1] + length[1];
+        length[2] = length[1];
+
+        blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 3);
+        blitStream.setSrcConfig(srcWStride, srcHStride, eYV12, eInterlace_None, &srcRoi);
+    }
+    else if (mSrcFormat == OMX_COLOR_FormatVendorMTKYUV) {
+        char* planar[2];
+        unsigned int length[2];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = srcWStride*srcHStride/2;
+
+        blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 2);
+        blitStream.setSrcConfig(srcWStride, srcHStride, srcWStride * 32, srcWStride * 16, eNV12_BLK, DP_PROFILE_BT601, eInterlace_None, &srcRoi);
+    }
+    else if (mSrcFormat == OMX_COLOR_FormatVendorMTKYUV_FCM) {
+        char* planar[2];
+        unsigned int length[2];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = srcWStride*srcHStride/2;
+
+        blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 2);
+        blitStream.setSrcConfig(srcWStride, srcHStride, srcWStride * 32, srcWStride * 16, eNV12_BLK_FCM, DP_PROFILE_BT601, eInterlace_None, &srcRoi);
+    }
+
+    if (mDstFormat == OMX_COLOR_Format16bitRGB565) {
+        blitStream.setDstBuffer(dst.mBits, dst.mWidth * dst.mHeight * 2);
+        blitStream.setDstConfig(dst.mWidth, dst.mHeight, eRGB565);
+    }
+    else if (mDstFormat == OMX_COLOR_Format32bitARGB8888) {
+        blitStream.setDstBuffer(dst.mBits, dst.mWidth * dst.mHeight * 4);
+        blitStream.setDstConfig(dst.mWidth, dst.mHeight, eRGBA8888);
+    }
+
+    // Add Sharpness in Video Thumbnail
+    blitStream.setTdshp(1);
+    bool bRet = blitStream.invalidate();
+
+    if (!bRet)
+        return OK;
+    else
+        return UNKNOWN_ERROR;
+}
+#endif
+
 }  // namespace android
diff --git a/media/libstagefright/filters/GraphicBufferListener.cpp b/media/libstagefright/filters/GraphicBufferListener.cpp
index a6063157e..952840b8f 100644
--- a/media/libstagefright/filters/GraphicBufferListener.cpp
+++ b/media/libstagefright/filters/GraphicBufferListener.cpp
@@ -21,8 +21,6 @@
 #include <media/stagefright/foundation/AMessage.h>
 #include <media/stagefright/MediaErrors.h>
 
-#include <gui/BufferItem.h>
-
 #include "GraphicBufferListener.h"
 
 namespace android {
@@ -85,8 +83,8 @@ void GraphicBufferListener::onSidebandStreamChanged() {
     // nothing to do
 }
 
-BufferItem GraphicBufferListener::getBufferItem() {
-    BufferItem item;
+BufferQueue::BufferItem GraphicBufferListener::getBufferItem() {
+    BufferQueue::BufferItem item;
 
     {
         Mutex::Autolock autoLock(mMutex);
@@ -126,7 +124,8 @@ BufferItem GraphicBufferListener::getBufferItem() {
     return item;
 }
 
-sp<GraphicBuffer> GraphicBufferListener::getBuffer(BufferItem item) {
+sp<GraphicBuffer> GraphicBufferListener::getBuffer(
+        BufferQueue::BufferItem item) {
     sp<GraphicBuffer> buf;
     if (item.mBuf < 0 || item.mBuf >= BufferQueue::NUM_BUFFER_SLOTS) {
         ALOGE("getBuffer() received invalid BufferItem: mBuf==%d", item.mBuf);
@@ -139,7 +138,8 @@ sp<GraphicBuffer> GraphicBufferListener::getBuffer(BufferItem item) {
     return buf;
 }
 
-status_t GraphicBufferListener::releaseBuffer(BufferItem item) {
+status_t GraphicBufferListener::releaseBuffer(
+        BufferQueue::BufferItem item) {
     if (item.mBuf < 0 || item.mBuf >= BufferQueue::NUM_BUFFER_SLOTS) {
         ALOGE("getBuffer() received invalid BufferItem: mBuf==%d", item.mBuf);
         return ERROR_OUT_OF_RANGE;
diff --git a/media/libstagefright/filters/GraphicBufferListener.h b/media/libstagefright/filters/GraphicBufferListener.h
index 586bf65d6..b3e0ee3e1 100644
--- a/media/libstagefright/filters/GraphicBufferListener.h
+++ b/media/libstagefright/filters/GraphicBufferListener.h
@@ -41,9 +41,9 @@ struct GraphicBufferListener : public BufferQueue::ConsumerListener {
         return mProducer;
     }
 
-    BufferItem getBufferItem();
-    sp<GraphicBuffer> getBuffer(BufferItem item);
-    status_t releaseBuffer(BufferItem item);
+    BufferQueue::BufferItem getBufferItem();
+    sp<GraphicBuffer> getBuffer(BufferQueue::BufferItem item);
+    status_t releaseBuffer(BufferQueue::BufferItem item);
 
     enum {
         kWhatFrameAvailable = 'frav',
diff --git a/media/libstagefright/filters/MediaFilter.cpp b/media/libstagefright/filters/MediaFilter.cpp
index 0cf6b0669..180645425 100644
--- a/media/libstagefright/filters/MediaFilter.cpp
+++ b/media/libstagefright/filters/MediaFilter.cpp
@@ -31,8 +31,6 @@
 #include <media/stagefright/MediaErrors.h>
 #include <media/stagefright/MediaFilter.h>
 
-#include <gui/BufferItem.h>
-
 #include "ColorConvert.h"
 #include "GraphicBufferListener.h"
 #include "IntrinsicBlurFilter.h"
@@ -756,7 +754,7 @@ void MediaFilter::onCreateInputSurface() {
 }
 
 void MediaFilter::onInputFrameAvailable() {
-    BufferItem item = mGraphicBufferListener->getBufferItem();
+    BufferQueue::BufferItem item = mGraphicBufferListener->getBufferItem();
     sp<GraphicBuffer> buf = mGraphicBufferListener->getBuffer(item);
 
     // get pointer to graphic buffer
diff --git a/media/libstagefright/omx/GraphicBufferSource.cpp b/media/libstagefright/omx/GraphicBufferSource.cpp
index 1a7dc9d9d..65a97da9c 100644
--- a/media/libstagefright/omx/GraphicBufferSource.cpp
+++ b/media/libstagefright/omx/GraphicBufferSource.cpp
@@ -57,7 +57,7 @@ void GraphicBufferSource::PersistentProxyListener::onFrameAvailable(
         if (consumer == NULL) {
             return;
         }
-        BufferItem bi;
+        BufferQueue::BufferItem bi;
         status_t err = consumer->acquireBuffer(&bi, 0);
         if (err != OK) {
             ALOGE("PersistentProxyListener: acquireBuffer failed (%d)", err);
@@ -461,7 +461,7 @@ void GraphicBufferSource::suspend(bool suspend) {
         mSuspended = true;
 
         while (mNumFramesAvailable > 0) {
-            BufferItem item;
+            BufferQueue::BufferItem item;
             status_t err = mConsumer->acquireBuffer(&item, 0);
 
             if (err == BufferQueue::NO_BUFFER_AVAILABLE) {
@@ -512,7 +512,7 @@ bool GraphicBufferSource::fillCodecBuffer_l() {
 
     ALOGV("fillCodecBuffer_l: acquiring buffer, avail=%zu",
             mNumFramesAvailable);
-    BufferItem item;
+    BufferQueue::BufferItem item;
     status_t err = mConsumer->acquireBuffer(&item, 0);
     if (err == BufferQueue::NO_BUFFER_AVAILABLE) {
         // shouldn't happen
@@ -599,7 +599,7 @@ bool GraphicBufferSource::repeatLatestBuffer_l() {
         return false;
     }
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
     item.mBuf = mLatestBufferId;
     item.mFrameNumber = mLatestBufferFrameNum;
     item.mTimestamp = mRepeatLastFrameTimestamp;
@@ -631,7 +631,7 @@ bool GraphicBufferSource::repeatLatestBuffer_l() {
 }
 
 void GraphicBufferSource::setLatestBuffer_l(
-        const BufferItem &item, bool dropped) {
+        const BufferQueue::BufferItem &item, bool dropped) {
     ALOGV("setLatestBuffer_l");
 
     if (mLatestBufferId >= 0) {
@@ -685,7 +685,7 @@ status_t GraphicBufferSource::signalEndOfInputStream() {
     return OK;
 }
 
-int64_t GraphicBufferSource::getTimestamp(const BufferItem &item) {
+int64_t GraphicBufferSource::getTimestamp(const BufferQueue::BufferItem &item) {
     int64_t timeUs = item.mTimestamp / 1000;
 
     if (mTimePerCaptureUs > 0ll) {
@@ -745,7 +745,8 @@ int64_t GraphicBufferSource::getTimestamp(const BufferItem &item) {
     return timeUs;
 }
 
-status_t GraphicBufferSource::submitBuffer_l(const BufferItem &item, int cbi) {
+status_t GraphicBufferSource::submitBuffer_l(
+        const BufferQueue::BufferItem &item, int cbi) {
     ALOGV("submitBuffer_l cbi=%d", cbi);
 
     int64_t timeUs = getTimestamp(item);
@@ -872,7 +873,7 @@ void GraphicBufferSource::onFrameAvailable(const BufferItem& /*item*/) {
             ALOGV("onFrameAvailable: suspended, ignoring frame");
         }
 
-        BufferItem item;
+        BufferQueue::BufferItem item;
         status_t err = mConsumer->acquireBuffer(&item, 0);
         if (err == OK) {
             if (item.mBuf < 0 ||
diff --git a/media/libstagefright/omx/GraphicBufferSource.h b/media/libstagefright/omx/GraphicBufferSource.h
index 2f929d95c..d603308fe 100644
--- a/media/libstagefright/omx/GraphicBufferSource.h
+++ b/media/libstagefright/omx/GraphicBufferSource.h
@@ -223,7 +223,7 @@ class GraphicBufferSource : public BufferQueue::ConsumerListener {
 
     // Marks the mCodecBuffers entry as in-use, copies the GraphicBuffer
     // reference into the codec buffer, and submits the data to the codec.
-    status_t submitBuffer_l(const BufferItem &item, int cbi);
+    status_t submitBuffer_l(const BufferQueue::BufferItem &item, int cbi);
 
     // Submits an empty buffer, with the EOS flag set.   Returns without
     // doing anything if we don't have a codec buffer available.
@@ -234,9 +234,9 @@ class GraphicBufferSource : public BufferQueue::ConsumerListener {
             int &id, uint64_t frameNum,
             const sp<GraphicBuffer> buffer, const sp<Fence> &fence);
 
-    void setLatestBuffer_l(const BufferItem &item, bool dropped);
+    void setLatestBuffer_l(const BufferQueue::BufferItem &item, bool dropped);
     bool repeatLatestBuffer_l();
-    int64_t getTimestamp(const BufferItem &item);
+    int64_t getTimestamp(const BufferQueue::BufferItem &item);
 
     // Lock, covers all member variables.
     mutable Mutex mMutex;
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 23215dddb..2e1b6bb95 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -989,6 +989,18 @@ status_t AudioFlinger::setStreamVolume(audio_stream_type_t stream, float value,
         thread->setStreamVolume(stream, value);
     }
 
+#ifdef MTK_HARDWARE
+    // MTK FM Volume
+    if(stream == AUDIO_STREAM_MUSIC) {
+        sp<ThreadBase> thread;
+        thread = checkPlaybackThread_l(output);
+        if (thread == primaryPlaybackThread_l()) {
+            audio_hw_device_t *dev = mPrimaryHardwareDev->hwDevice();
+            dev->set_parameters (dev, String8::format("SetFmVolume=%f", value));
+        }
+    }
+#endif
+
     return NO_ERROR;
 }
 
diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index af46d6355..f56f8f325 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -742,6 +742,18 @@ void CameraClient::notifyCallback(int32_t msgType, int32_t ext1,
         int32_t ext2, void* user) {
     LOG2("notifyCallback(%d)", msgType);
 
+#ifdef MTK_HARDWARE
+    if (msgType == 0x40000000) { //MTK_CAMERA_MSG_EXT_NOTIFY
+        if (ext1 == 0x11) { //MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER
+            msgType = CAMERA_MSG_SHUTTER;
+        }
+        if (ext1 == 0x10) { //MTK_CAMERA_MSG_EXT_CAPTURE_DONE
+            return;
+        }
+        LOG2("MtknotifyCallback(0x%x, 0x%x)", ext1, ext2);
+    }
+#endif
+
     sp<CameraClient> client = static_cast<CameraClient*>(getClientFromCookie(user).get());
     if (client.get() == nullptr) return;
 
@@ -772,6 +784,34 @@ void CameraClient::dataCallback(int32_t msgType,
         return;
     }
 
+#ifdef MTK_HARDWARE
+    if (msgType == 0x80000000) { //MTK_CAMERA_MSG_EXT_DATA
+        struct DataHeader {
+            uint32_t        extMsgType;
+        } dataHeader;
+        sp<IMemoryHeap> heap = 0;
+        ssize_t         offset = 0;
+        size_t          size = 0;
+
+        if (dataPtr.get()) {
+
+            heap = dataPtr->getMemory(&offset, &size);
+            if  ( NULL != heap.get() && NULL != heap->base() )
+                ::memcpy(&dataHeader, ((uint8_t*)heap->base()) + offset, sizeof(DataHeader));
+
+            if (dataHeader.extMsgType == 0x10) { //MTK_CAMERA_MSG_EXT_DATA_COMPRESSED_IMAGE
+                msgType = CAMERA_MSG_COMPRESSED_IMAGE;
+                sp<MemoryBase> image = new MemoryBase(heap,
+                        (offset + sizeof(DataHeader) + sizeof(uint_t) * 1),
+                        (size - sizeof(DataHeader) - sizeof(uint_t) * 1));
+                client->handleCompressedPicture(image);
+                return;
+            }
+        }
+        LOG2("MtkDataCallback(0x%x)", dataHeader.extMsgType);
+    }
+#endif
+
     switch (msgType & ~CAMERA_MSG_PREVIEW_METADATA) {
         case CAMERA_MSG_PREVIEW_FRAME:
             client->handlePreviewData(msgType, dataPtr, metadata);
diff --git a/services/camera/libcameraservice/gui/RingBufferConsumer.cpp b/services/camera/libcameraservice/gui/RingBufferConsumer.cpp
index 8cd6800af..d0f29de06 100644
--- a/services/camera/libcameraservice/gui/RingBufferConsumer.cpp
+++ b/services/camera/libcameraservice/gui/RingBufferConsumer.cpp
@@ -268,7 +268,7 @@ status_t RingBufferConsumer::releaseOldestBufferLocked(size_t* pinnedFrames) {
     return OK;
 }
 
-void RingBufferConsumer::onFrameAvailable(const BufferItem& item) {
+void RingBufferConsumer::onFrameAvailable(const android::BufferItem& item) {
     status_t err;
 
     {
diff --git a/services/camera/libcameraservice/gui/RingBufferConsumer.h b/services/camera/libcameraservice/gui/RingBufferConsumer.h
index 83e7298e2..90fd7340d 100644
--- a/services/camera/libcameraservice/gui/RingBufferConsumer.h
+++ b/services/camera/libcameraservice/gui/RingBufferConsumer.h
@@ -17,7 +17,6 @@
 #ifndef ANDROID_GUI_RINGBUFFERCONSUMER_H
 #define ANDROID_GUI_RINGBUFFERCONSUMER_H
 
-#include <gui/BufferItem.h>
 #include <gui/ConsumerBase.h>
 
 #include <ui/GraphicBuffer.h>
@@ -55,6 +54,8 @@ class RingBufferConsumer : public ConsumerBase,
   public:
     typedef ConsumerBase::FrameAvailableListener FrameAvailableListener;
 
+    typedef BufferQueue::BufferItem BufferItem;
+
     enum { INVALID_BUFFER_SLOT = BufferQueue::INVALID_BUFFER_SLOT };
     enum { NO_BUFFER_AVAILABLE = BufferQueue::NO_BUFFER_AVAILABLE };
 
@@ -164,7 +165,7 @@ class RingBufferConsumer : public ConsumerBase,
   private:
 
     // Override ConsumerBase::onFrameAvailable
-    virtual void onFrameAvailable(const BufferItem& item);
+    virtual void onFrameAvailable(const android::BufferItem& item);
 
     void pinBufferLocked(const BufferItem& item);
     void unpinBuffer(const BufferItem& item);
